//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountClient {
    /**
     * @return Success
     */
    getAccountDetails(): Observable<AccountDetails>;
}

@Injectable()
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAccountDetails(): Observable<AccountDetails> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDetails>;
        }));
    }

    protected processGetAccountDetails(response: HttpResponseBase): Observable<AccountDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetails>(null as any);
    }
}

export interface IActionLogsClient {
    /**
     * @param searchModel_ActionEntity (optional) 
     * @param searchModel_ActionType (optional) 
     * @param searchModel_ActionSource (optional) 
     * @param searchModel_ActionEntityPk (optional) 
     * @param searchModel_UserName (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryLogs(searchModel_ActionEntity?: ActionEntity | undefined, searchModel_ActionType?: ActionType | undefined, searchModel_ActionSource?: ActionSource | undefined, searchModel_ActionEntityPk?: number | undefined, searchModel_UserName?: string | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ActionLogListItemPagingResponse>;
    /**
     * @return Success
     */
    getLogDetail(id: number): Observable<ActionLogListItem>;
    /**
     * @return Success
     */
    getActionLogEntities(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getActionLogTypes(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getActionLogSources(): Observable<DropDownListItemModel[]>;
    exportLogs(actionEntity?: ActionEntity | undefined, actionType?: ActionType | undefined, actionSource?: ActionSource | undefined, actionEntityPk?: number | undefined, userName?: string | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class ActionLogsClient implements IActionLogsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_ActionEntity (optional) 
     * @param searchModel_ActionType (optional) 
     * @param searchModel_ActionSource (optional) 
     * @param searchModel_ActionEntityPk (optional) 
     * @param searchModel_UserName (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryLogs(searchModel_ActionEntity?: ActionEntity | undefined, searchModel_ActionType?: ActionType | undefined, searchModel_ActionSource?: ActionSource | undefined, searchModel_ActionEntityPk?: number | undefined, searchModel_UserName?: string | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ActionLogListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/ActionLogs?";
        if (searchModel_ActionEntity === null)
            throw new Error("The parameter 'searchModel_ActionEntity' cannot be null.");
        else if (searchModel_ActionEntity !== undefined)
            url_ += "SearchModel.ActionEntity=" + encodeURIComponent("" + searchModel_ActionEntity) + "&";
        if (searchModel_ActionType === null)
            throw new Error("The parameter 'searchModel_ActionType' cannot be null.");
        else if (searchModel_ActionType !== undefined)
            url_ += "SearchModel.ActionType=" + encodeURIComponent("" + searchModel_ActionType) + "&";
        if (searchModel_ActionSource === null)
            throw new Error("The parameter 'searchModel_ActionSource' cannot be null.");
        else if (searchModel_ActionSource !== undefined)
            url_ += "SearchModel.ActionSource=" + encodeURIComponent("" + searchModel_ActionSource) + "&";
        if (searchModel_ActionEntityPk === null)
            throw new Error("The parameter 'searchModel_ActionEntityPk' cannot be null.");
        else if (searchModel_ActionEntityPk !== undefined)
            url_ += "SearchModel.ActionEntityPk=" + encodeURIComponent("" + searchModel_ActionEntityPk) + "&";
        if (searchModel_UserName === null)
            throw new Error("The parameter 'searchModel_UserName' cannot be null.");
        else if (searchModel_UserName !== undefined)
            url_ += "SearchModel.UserName=" + encodeURIComponent("" + searchModel_UserName) + "&";
        if (searchModel_DateCreated_From === null)
            throw new Error("The parameter 'searchModel_DateCreated_From' cannot be null.");
        else if (searchModel_DateCreated_From !== undefined)
            url_ += "SearchModel.DateCreated.From=" + encodeURIComponent(searchModel_DateCreated_From ? "" + searchModel_DateCreated_From.toISOString() : "") + "&";
        if (searchModel_DateCreated_To === null)
            throw new Error("The parameter 'searchModel_DateCreated_To' cannot be null.");
        else if (searchModel_DateCreated_To !== undefined)
            url_ += "SearchModel.DateCreated.To=" + encodeURIComponent(searchModel_DateCreated_To ? "" + searchModel_DateCreated_To.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItemPagingResponse>;
        }));
    }

    protected processQueryLogs(response: HttpResponseBase): Observable<ActionLogListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItemPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    getLogDetail(id: number): Observable<ActionLogListItem> {
        let url_ = this.baseUrl + "/api/ActionLogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem>;
        }));
    }

    protected processGetLogDetail(response: HttpResponseBase): Observable<ActionLogListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem>(null as any);
    }

    /**
     * @return Success
     */
    getActionLogEntities(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/ActionLogs/GetActionLogEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionLogEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionLogEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetActionLogEntities(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getActionLogTypes(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/ActionLogs/GetActionLogTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionLogTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionLogTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetActionLogTypes(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getActionLogSources(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/ActionLogs/GetActionLogSources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionLogSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionLogSources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetActionLogSources(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    exportLogs(actionEntity?: ActionEntity | undefined, actionType?: ActionType | undefined, actionSource?: ActionSource | undefined, actionEntityPk?: number | undefined, userName?: string | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ActionLogs/Export?";
        if (actionEntity === null)
            throw new Error("The parameter 'actionEntity' cannot be null.");
        else if (actionEntity !== undefined)
            url_ += "ActionEntity=" + encodeURIComponent("" + actionEntity) + "&";
        if (actionType === null)
            throw new Error("The parameter 'actionType' cannot be null.");
        else if (actionType !== undefined)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        if (actionSource === null)
            throw new Error("The parameter 'actionSource' cannot be null.");
        else if (actionSource !== undefined)
            url_ += "ActionSource=" + encodeURIComponent("" + actionSource) + "&";
        if (actionEntityPk === null)
            throw new Error("The parameter 'actionEntityPk' cannot be null.");
        else if (actionEntityPk !== undefined)
            url_ += "ActionEntityPk=" + encodeURIComponent("" + actionEntityPk) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent(dateCreated_From ? "" + dateCreated_From.toISOString() : "") + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent(dateCreated_To ? "" + dateCreated_To.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportLogs(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface ICallBackClient {
    /**
     * @param searchModel_Url (optional) 
     * @param searchModel_Host (optional) 
     * @param searchModel_WebAddress (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Status (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getCallBacks(searchModel_Url?: string | undefined, searchModel_Host?: string | undefined, searchModel_WebAddress?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Status?: CallBackStatus | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CallBackVmPagingResponse>;
    /**
     * @return Success
     */
    activateCallBack(callBackId: number): Observable<ApiResponse>;
    /**
     * @param comment (optional) 
     * @return Success
     */
    declineCallBack(callBackId: number, comment?: string | undefined): Observable<ApiResponse>;
    /**
     * @return Success
     */
    getCallBackLogs(callBackId: number): Observable<ActionLogListItem[]>;
}

@Injectable()
export class CallBackClient implements ICallBackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_Url (optional) 
     * @param searchModel_Host (optional) 
     * @param searchModel_WebAddress (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Status (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getCallBacks(searchModel_Url?: string | undefined, searchModel_Host?: string | undefined, searchModel_WebAddress?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Status?: CallBackStatus | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CallBackVmPagingResponse> {
        let url_ = this.baseUrl + "/api/callbacks?";
        if (searchModel_Url === null)
            throw new Error("The parameter 'searchModel_Url' cannot be null.");
        else if (searchModel_Url !== undefined)
            url_ += "SearchModel.Url=" + encodeURIComponent("" + searchModel_Url) + "&";
        if (searchModel_Host === null)
            throw new Error("The parameter 'searchModel_Host' cannot be null.");
        else if (searchModel_Host !== undefined)
            url_ += "SearchModel.Host=" + encodeURIComponent("" + searchModel_Host) + "&";
        if (searchModel_WebAddress === null)
            throw new Error("The parameter 'searchModel_WebAddress' cannot be null.");
        else if (searchModel_WebAddress !== undefined)
            url_ += "SearchModel.WebAddress=" + encodeURIComponent("" + searchModel_WebAddress) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallBacks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallBacks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CallBackVmPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CallBackVmPagingResponse>;
        }));
    }

    protected processGetCallBacks(response: HttpResponseBase): Observable<CallBackVmPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CallBackVmPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBackVmPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    activateCallBack(callBackId: number): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/callbacks/{callBackId}/activate";
        if (callBackId === undefined || callBackId === null)
            throw new Error("The parameter 'callBackId' must be defined.");
        url_ = url_.replace("{callBackId}", encodeURIComponent("" + callBackId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateCallBack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processActivateCallBack(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param comment (optional) 
     * @return Success
     */
    declineCallBack(callBackId: number, comment?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/callbacks/{callBackId}/decline?";
        if (callBackId === undefined || callBackId === null)
            throw new Error("The parameter 'callBackId' must be defined.");
        url_ = url_.replace("{callBackId}", encodeURIComponent("" + callBackId));
        if (comment === null)
            throw new Error("The parameter 'comment' cannot be null.");
        else if (comment !== undefined)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeclineCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeclineCallBack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeclineCallBack(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    getCallBackLogs(callBackId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/callbacks/{callBackId}/Logs";
        if (callBackId === undefined || callBackId === null)
            throw new Error("The parameter 'callBackId' must be defined.");
        url_ = url_.replace("{callBackId}", encodeURIComponent("" + callBackId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallBackLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallBackLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetCallBackLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }
}

export interface ICardClient {
    /**
     * @param searchModel_UserFullName (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_PersonalId (optional) 
     * @param searchModel_Product (optional) 
     * @param searchModel_CardType (optional) 
     * @param searchModel_CardMask (optional) 
     * @param searchModel_CardStatus (optional) 
     * @param searchModel_IsPrimary (optional) 
     * @param searchModel_CreatedAt_From (optional) 
     * @param searchModel_CreatedAt_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryCards(searchModel_UserFullName?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_PersonalId?: string | undefined, searchModel_Product?: string | undefined, searchModel_CardType?: CreditCardStatus | undefined, searchModel_CardMask?: string | undefined, searchModel_CardStatus?: CardStatus | undefined, searchModel_IsPrimary?: boolean | undefined, searchModel_CreatedAt_From?: moment.Moment | undefined, searchModel_CreatedAt_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CardsListItemPagingResponse>;
    /**
     * @return Success
     */
    getCard(id: number): Observable<CardDetailsModel>;
    exportCards(userFullName?: string | undefined, clientNo?: string | undefined, personalId?: string | undefined, product?: string | undefined, cardType?: CreditCardStatus | undefined, cardMask?: string | undefined, cardStatus?: CardStatus | undefined, isPrimary?: boolean | undefined, createdAt_From?: moment.Moment | undefined, createdAt_To?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class CardClient implements ICardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_UserFullName (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_PersonalId (optional) 
     * @param searchModel_Product (optional) 
     * @param searchModel_CardType (optional) 
     * @param searchModel_CardMask (optional) 
     * @param searchModel_CardStatus (optional) 
     * @param searchModel_IsPrimary (optional) 
     * @param searchModel_CreatedAt_From (optional) 
     * @param searchModel_CreatedAt_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryCards(searchModel_UserFullName?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_PersonalId?: string | undefined, searchModel_Product?: string | undefined, searchModel_CardType?: CreditCardStatus | undefined, searchModel_CardMask?: string | undefined, searchModel_CardStatus?: CardStatus | undefined, searchModel_IsPrimary?: boolean | undefined, searchModel_CreatedAt_From?: moment.Moment | undefined, searchModel_CreatedAt_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CardsListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/Card?";
        if (searchModel_UserFullName === null)
            throw new Error("The parameter 'searchModel_UserFullName' cannot be null.");
        else if (searchModel_UserFullName !== undefined)
            url_ += "SearchModel.UserFullName=" + encodeURIComponent("" + searchModel_UserFullName) + "&";
        if (searchModel_ClientNo === null)
            throw new Error("The parameter 'searchModel_ClientNo' cannot be null.");
        else if (searchModel_ClientNo !== undefined)
            url_ += "SearchModel.ClientNo=" + encodeURIComponent("" + searchModel_ClientNo) + "&";
        if (searchModel_PersonalId === null)
            throw new Error("The parameter 'searchModel_PersonalId' cannot be null.");
        else if (searchModel_PersonalId !== undefined)
            url_ += "SearchModel.PersonalId=" + encodeURIComponent("" + searchModel_PersonalId) + "&";
        if (searchModel_Product === null)
            throw new Error("The parameter 'searchModel_Product' cannot be null.");
        else if (searchModel_Product !== undefined)
            url_ += "SearchModel.Product=" + encodeURIComponent("" + searchModel_Product) + "&";
        if (searchModel_CardType === null)
            throw new Error("The parameter 'searchModel_CardType' cannot be null.");
        else if (searchModel_CardType !== undefined)
            url_ += "SearchModel.CardType=" + encodeURIComponent("" + searchModel_CardType) + "&";
        if (searchModel_CardMask === null)
            throw new Error("The parameter 'searchModel_CardMask' cannot be null.");
        else if (searchModel_CardMask !== undefined)
            url_ += "SearchModel.CardMask=" + encodeURIComponent("" + searchModel_CardMask) + "&";
        if (searchModel_CardStatus === null)
            throw new Error("The parameter 'searchModel_CardStatus' cannot be null.");
        else if (searchModel_CardStatus !== undefined)
            url_ += "SearchModel.CardStatus=" + encodeURIComponent("" + searchModel_CardStatus) + "&";
        if (searchModel_IsPrimary === null)
            throw new Error("The parameter 'searchModel_IsPrimary' cannot be null.");
        else if (searchModel_IsPrimary !== undefined)
            url_ += "SearchModel.IsPrimary=" + encodeURIComponent("" + searchModel_IsPrimary) + "&";
        if (searchModel_CreatedAt_From === null)
            throw new Error("The parameter 'searchModel_CreatedAt_From' cannot be null.");
        else if (searchModel_CreatedAt_From !== undefined)
            url_ += "SearchModel.CreatedAt.From=" + encodeURIComponent(searchModel_CreatedAt_From ? "" + searchModel_CreatedAt_From.toISOString() : "") + "&";
        if (searchModel_CreatedAt_To === null)
            throw new Error("The parameter 'searchModel_CreatedAt_To' cannot be null.");
        else if (searchModel_CreatedAt_To !== undefined)
            url_ += "SearchModel.CreatedAt.To=" + encodeURIComponent(searchModel_CreatedAt_To ? "" + searchModel_CreatedAt_To.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CardsListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CardsListItemPagingResponse>;
        }));
    }

    protected processQueryCards(response: HttpResponseBase): Observable<CardsListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CardsListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardsListItemPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    getCard(id: number): Observable<CardDetailsModel> {
        let url_ = this.baseUrl + "/api/Card/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CardDetailsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CardDetailsModel>;
        }));
    }

    protected processGetCard(response: HttpResponseBase): Observable<CardDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CardDetailsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDetailsModel>(null as any);
    }

    exportCards(userFullName?: string | undefined, clientNo?: string | undefined, personalId?: string | undefined, product?: string | undefined, cardType?: CreditCardStatus | undefined, cardMask?: string | undefined, cardStatus?: CardStatus | undefined, isPrimary?: boolean | undefined, createdAt_From?: moment.Moment | undefined, createdAt_To?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Card/Export?";
        if (userFullName === null)
            throw new Error("The parameter 'userFullName' cannot be null.");
        else if (userFullName !== undefined)
            url_ += "UserFullName=" + encodeURIComponent("" + userFullName) + "&";
        if (clientNo === null)
            throw new Error("The parameter 'clientNo' cannot be null.");
        else if (clientNo !== undefined)
            url_ += "ClientNo=" + encodeURIComponent("" + clientNo) + "&";
        if (personalId === null)
            throw new Error("The parameter 'personalId' cannot be null.");
        else if (personalId !== undefined)
            url_ += "PersonalId=" + encodeURIComponent("" + personalId) + "&";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (cardType === null)
            throw new Error("The parameter 'cardType' cannot be null.");
        else if (cardType !== undefined)
            url_ += "CardType=" + encodeURIComponent("" + cardType) + "&";
        if (cardMask === null)
            throw new Error("The parameter 'cardMask' cannot be null.");
        else if (cardMask !== undefined)
            url_ += "CardMask=" + encodeURIComponent("" + cardMask) + "&";
        if (cardStatus === null)
            throw new Error("The parameter 'cardStatus' cannot be null.");
        else if (cardStatus !== undefined)
            url_ += "CardStatus=" + encodeURIComponent("" + cardStatus) + "&";
        if (isPrimary === null)
            throw new Error("The parameter 'isPrimary' cannot be null.");
        else if (isPrimary !== undefined)
            url_ += "IsPrimary=" + encodeURIComponent("" + isPrimary) + "&";
        if (createdAt_From === null)
            throw new Error("The parameter 'createdAt_From' cannot be null.");
        else if (createdAt_From !== undefined)
            url_ += "CreatedAt.From=" + encodeURIComponent(createdAt_From ? "" + createdAt_From.toISOString() : "") + "&";
        if (createdAt_To === null)
            throw new Error("The parameter 'createdAt_To' cannot be null.");
        else if (createdAt_To !== undefined)
            url_ += "CreatedAt.To=" + encodeURIComponent(createdAt_To ? "" + createdAt_To.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportCards(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface ICertificateClient {
    certificatePOST(file?: FileParameter | undefined): Observable<void>;
    /**
     * @param searchModel_MerchantId (optional) 
     * @param searchModel_ValidFromFrom (optional) 
     * @param searchModel_ValidFromTo (optional) 
     * @param searchModel_ValidToFrom (optional) 
     * @param searchModel_ValidToTo (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_DateModifiedFrom (optional) 
     * @param searchModel_DateModifiedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    certificateGET(searchModel_MerchantId?: string | undefined, searchModel_ValidFromFrom?: moment.Moment | undefined, searchModel_ValidFromTo?: moment.Moment | undefined, searchModel_ValidToFrom?: moment.Moment | undefined, searchModel_ValidToTo?: moment.Moment | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_DateModifiedFrom?: moment.Moment | undefined, searchModel_DateModifiedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<UfcCertificateModelPagingResponse>;
}

@Injectable()
export class CertificateClient implements ICertificateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    certificatePOST(file?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Certificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCertificatePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCertificatePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCertificatePOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param searchModel_MerchantId (optional) 
     * @param searchModel_ValidFromFrom (optional) 
     * @param searchModel_ValidFromTo (optional) 
     * @param searchModel_ValidToFrom (optional) 
     * @param searchModel_ValidToTo (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_DateModifiedFrom (optional) 
     * @param searchModel_DateModifiedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    certificateGET(searchModel_MerchantId?: string | undefined, searchModel_ValidFromFrom?: moment.Moment | undefined, searchModel_ValidFromTo?: moment.Moment | undefined, searchModel_ValidToFrom?: moment.Moment | undefined, searchModel_ValidToTo?: moment.Moment | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_DateModifiedFrom?: moment.Moment | undefined, searchModel_DateModifiedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<UfcCertificateModelPagingResponse> {
        let url_ = this.baseUrl + "/api/Certificate?";
        if (searchModel_MerchantId === null)
            throw new Error("The parameter 'searchModel_MerchantId' cannot be null.");
        else if (searchModel_MerchantId !== undefined)
            url_ += "SearchModel.MerchantId=" + encodeURIComponent("" + searchModel_MerchantId) + "&";
        if (searchModel_ValidFromFrom === null)
            throw new Error("The parameter 'searchModel_ValidFromFrom' cannot be null.");
        else if (searchModel_ValidFromFrom !== undefined)
            url_ += "SearchModel.ValidFromFrom=" + encodeURIComponent(searchModel_ValidFromFrom ? "" + searchModel_ValidFromFrom.toISOString() : "") + "&";
        if (searchModel_ValidFromTo === null)
            throw new Error("The parameter 'searchModel_ValidFromTo' cannot be null.");
        else if (searchModel_ValidFromTo !== undefined)
            url_ += "SearchModel.ValidFromTo=" + encodeURIComponent(searchModel_ValidFromTo ? "" + searchModel_ValidFromTo.toISOString() : "") + "&";
        if (searchModel_ValidToFrom === null)
            throw new Error("The parameter 'searchModel_ValidToFrom' cannot be null.");
        else if (searchModel_ValidToFrom !== undefined)
            url_ += "SearchModel.ValidToFrom=" + encodeURIComponent(searchModel_ValidToFrom ? "" + searchModel_ValidToFrom.toISOString() : "") + "&";
        if (searchModel_ValidToTo === null)
            throw new Error("The parameter 'searchModel_ValidToTo' cannot be null.");
        else if (searchModel_ValidToTo !== undefined)
            url_ += "SearchModel.ValidToTo=" + encodeURIComponent(searchModel_ValidToTo ? "" + searchModel_ValidToTo.toISOString() : "") + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (searchModel_DateModifiedFrom === null)
            throw new Error("The parameter 'searchModel_DateModifiedFrom' cannot be null.");
        else if (searchModel_DateModifiedFrom !== undefined)
            url_ += "SearchModel.DateModifiedFrom=" + encodeURIComponent(searchModel_DateModifiedFrom ? "" + searchModel_DateModifiedFrom.toISOString() : "") + "&";
        if (searchModel_DateModifiedTo === null)
            throw new Error("The parameter 'searchModel_DateModifiedTo' cannot be null.");
        else if (searchModel_DateModifiedTo !== undefined)
            url_ += "SearchModel.DateModifiedTo=" + encodeURIComponent(searchModel_DateModifiedTo ? "" + searchModel_DateModifiedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCertificateGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCertificateGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UfcCertificateModelPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UfcCertificateModelPagingResponse>;
        }));
    }

    protected processCertificateGET(response: HttpResponseBase): Observable<UfcCertificateModelPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UfcCertificateModelPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UfcCertificateModelPagingResponse>(null as any);
    }
}

export interface ICompanyClient {
    /**
     * @param searchModel_TradeName (optional) 
     * @param searchModel_IdentificationNumber (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_CompanyEmail (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_AdminCreator (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryCompanies(searchModel_TradeName?: string | undefined, searchModel_IdentificationNumber?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_CompanyEmail?: string | undefined, searchModel_Status?: CompanyStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_AdminCreator?: string | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CompanyModelPagingResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body?: RegisterCompanyRequest | undefined): Observable<IdResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveCompany(body?: UpdateCompany | undefined): Observable<void>;
    /**
     * @return Success
     */
    getCompany(id: number): Observable<CompanyDetailsResponseModel>;
    companyWithSameIdExists(identificationId: string): Observable<void>;
    companyWithSameClientNoExists(clientNo: string): Observable<void>;
    merchantWithSameMerchantIdExists(merchantId: string): Observable<void>;
    /**
     * @return Success
     */
    getCompanyLogs(id: number): Observable<ActionLogListItem[]>;
    /**
     * @param userId (optional) 
     * @param confirmed (optional) 
     * @return No Content
     */
    confirmUserRoleChange(id: number, userId?: number | undefined, confirmed?: boolean | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    addUserToCompany(companyId: number, body?: AddUserToCompany | undefined): Observable<void>;
    /**
     * @param userId (optional) 
     * @return No Content
     */
    deleteUserFromCompany(id: number, userId?: number | undefined): Observable<void>;
    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserCompanyDetails(companyId: number, userId?: number | undefined): Observable<UserCompanyDetails>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    changeUserRoleAndPaymentMerchants(companyId: number, body?: ChangeUserRoleAndPaymentMerchants | undefined): Observable<void>;
    /**
     * @return No Content
     */
    changeStatus(id: number, status: CompanyStatus): Observable<void>;
    /**
     * @return Success
     */
    findCompanyByIdentificationNumber(identificationNumber: string): Observable<CompanyModel>;
    /**
     * @return Success
     */
    merchantPaymentDefaultLimits(merchantType: MerchantType): Observable<MerchantPaymentLimit>;
    /**
     * @return Success
     */
    merchantRefundDefaultLimits(merchantType: MerchantType): Observable<MerchantRefundLimit>;
    /**
     * @return Success
     */
    mccCodes(): Observable<MccCode[]>;
    /**
     * @return Success
     */
    getCompanyPaymentMerchants(companyId: number): Observable<PaymentMerchantData[]>;
    /**
     * @param webPage (optional) 
     * @return Success
     */
    getWebPageDropDownItems(companyId: number, webPage?: number | undefined): Observable<WebPageDropDownItem[]>;
}

@Injectable()
export class CompanyClient implements ICompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_TradeName (optional) 
     * @param searchModel_IdentificationNumber (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_CompanyEmail (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_AdminCreator (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryCompanies(searchModel_TradeName?: string | undefined, searchModel_IdentificationNumber?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_CompanyEmail?: string | undefined, searchModel_Status?: CompanyStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_AdminCreator?: string | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<CompanyModelPagingResponse> {
        let url_ = this.baseUrl + "/api/Company?";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_IdentificationNumber === null)
            throw new Error("The parameter 'searchModel_IdentificationNumber' cannot be null.");
        else if (searchModel_IdentificationNumber !== undefined)
            url_ += "SearchModel.IdentificationNumber=" + encodeURIComponent("" + searchModel_IdentificationNumber) + "&";
        if (searchModel_ClientNo === null)
            throw new Error("The parameter 'searchModel_ClientNo' cannot be null.");
        else if (searchModel_ClientNo !== undefined)
            url_ += "SearchModel.ClientNo=" + encodeURIComponent("" + searchModel_ClientNo) + "&";
        if (searchModel_CompanyEmail === null)
            throw new Error("The parameter 'searchModel_CompanyEmail' cannot be null.");
        else if (searchModel_CompanyEmail !== undefined)
            url_ += "SearchModel.CompanyEmail=" + encodeURIComponent("" + searchModel_CompanyEmail) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (searchModel_AdminCreator === null)
            throw new Error("The parameter 'searchModel_AdminCreator' cannot be null.");
        else if (searchModel_AdminCreator !== undefined)
            url_ += "SearchModel.AdminCreator=" + encodeURIComponent("" + searchModel_AdminCreator) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyModelPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyModelPagingResponse>;
        }));
    }

    protected processQueryCompanies(response: HttpResponseBase): Observable<CompanyModelPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompanyModelPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModelPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body?: RegisterCompanyRequest | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/Company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processRegisterCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveCompany(body?: UpdateCompany | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCompany(id: number): Observable<CompanyDetailsResponseModel> {
        let url_ = this.baseUrl + "/api/Company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDetailsResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDetailsResponseModel>;
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<CompanyDetailsResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompanyDetailsResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDetailsResponseModel>(null as any);
    }

    companyWithSameIdExists(identificationId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{identificationId}/ExistsCompanyWithThisId";
        if (identificationId === undefined || identificationId === null)
            throw new Error("The parameter 'identificationId' must be defined.");
        url_ = url_.replace("{identificationId}", encodeURIComponent("" + identificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyWithSameIdExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyWithSameIdExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompanyWithSameIdExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    companyWithSameClientNoExists(clientNo: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{clientNo}/ExistsCompanyWithThisCompanyNo";
        if (clientNo === undefined || clientNo === null)
            throw new Error("The parameter 'clientNo' must be defined.");
        url_ = url_.replace("{clientNo}", encodeURIComponent("" + clientNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyWithSameClientNoExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyWithSameClientNoExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompanyWithSameClientNoExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    merchantWithSameMerchantIdExists(merchantId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{merchantId}/ExistsMerchantWithThisMerchantId";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMerchantWithSameMerchantIdExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMerchantWithSameMerchantIdExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMerchantWithSameMerchantIdExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCompanyLogs(id: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/Company/{id}/Logs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetCompanyLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param confirmed (optional) 
     * @return No Content
     */
    confirmUserRoleChange(id: number, userId?: number | undefined, confirmed?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{id}/ConfirmUserRoleChange?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (confirmed === null)
            throw new Error("The parameter 'confirmed' cannot be null.");
        else if (confirmed !== undefined)
            url_ += "confirmed=" + encodeURIComponent("" + confirmed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUserRoleChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUserRoleChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmUserRoleChange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    addUserToCompany(companyId: number, body?: AddUserToCompany | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{companyId}/AddUserToCompany";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUserToCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return No Content
     */
    deleteUserFromCompany(id: number, userId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{id}/DeleteUserFromCompany?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserFromCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserFromCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserFromCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserCompanyDetails(companyId: number, userId?: number | undefined): Observable<UserCompanyDetails> {
        let url_ = this.baseUrl + "/api/Company/{companyId}/UserCompanyDetails?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCompanyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCompanyDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserCompanyDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserCompanyDetails>;
        }));
    }

    protected processGetUserCompanyDetails(response: HttpResponseBase): Observable<UserCompanyDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserCompanyDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCompanyDetails>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    changeUserRoleAndPaymentMerchants(companyId: number, body?: ChangeUserRoleAndPaymentMerchants | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{companyId}/ChangeUserRoleAndPaymentMerchants";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserRoleAndPaymentMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserRoleAndPaymentMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUserRoleAndPaymentMerchants(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return No Content
     */
    changeStatus(id: number, status: CompanyStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/Company/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    findCompanyByIdentificationNumber(identificationNumber: string): Observable<CompanyModel> {
        let url_ = this.baseUrl + "/api/Company/{identificationNumber}/Info";
        if (identificationNumber === undefined || identificationNumber === null)
            throw new Error("The parameter 'identificationNumber' must be defined.");
        url_ = url_.replace("{identificationNumber}", encodeURIComponent("" + identificationNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindCompanyByIdentificationNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindCompanyByIdentificationNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyModel>;
        }));
    }

    protected processFindCompanyByIdentificationNumber(response: HttpResponseBase): Observable<CompanyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompanyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModel>(null as any);
    }

    /**
     * @return Success
     */
    merchantPaymentDefaultLimits(merchantType: MerchantType): Observable<MerchantPaymentLimit> {
        let url_ = this.baseUrl + "/api/Company/MerchantPaymentDefaultLimits/Type/{merchantType}";
        if (merchantType === undefined || merchantType === null)
            throw new Error("The parameter 'merchantType' must be defined.");
        url_ = url_.replace("{merchantType}", encodeURIComponent("" + merchantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMerchantPaymentDefaultLimits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMerchantPaymentDefaultLimits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantPaymentLimit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantPaymentLimit>;
        }));
    }

    protected processMerchantPaymentDefaultLimits(response: HttpResponseBase): Observable<MerchantPaymentLimit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MerchantPaymentLimit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MerchantPaymentLimit>(null as any);
    }

    /**
     * @return Success
     */
    merchantRefundDefaultLimits(merchantType: MerchantType): Observable<MerchantRefundLimit> {
        let url_ = this.baseUrl + "/api/Company/MerchantRefundDefaultLimits/Type/{merchantType}";
        if (merchantType === undefined || merchantType === null)
            throw new Error("The parameter 'merchantType' must be defined.");
        url_ = url_.replace("{merchantType}", encodeURIComponent("" + merchantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMerchantRefundDefaultLimits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMerchantRefundDefaultLimits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantRefundLimit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantRefundLimit>;
        }));
    }

    protected processMerchantRefundDefaultLimits(response: HttpResponseBase): Observable<MerchantRefundLimit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MerchantRefundLimit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MerchantRefundLimit>(null as any);
    }

    /**
     * @return Success
     */
    mccCodes(): Observable<MccCode[]> {
        let url_ = this.baseUrl + "/api/Company/MccCodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMccCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMccCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MccCode[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MccCode[]>;
        }));
    }

    protected processMccCodes(response: HttpResponseBase): Observable<MccCode[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MccCode[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MccCode[]>(null as any);
    }

    /**
     * @return Success
     */
    getCompanyPaymentMerchants(companyId: number): Observable<PaymentMerchantData[]> {
        let url_ = this.baseUrl + "/api/Company/{companyId}/PaymentMerchants";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyPaymentMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyPaymentMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMerchantData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMerchantData[]>;
        }));
    }

    protected processGetCompanyPaymentMerchants(response: HttpResponseBase): Observable<PaymentMerchantData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentMerchantData[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMerchantData[]>(null as any);
    }

    /**
     * @param webPage (optional) 
     * @return Success
     */
    getWebPageDropDownItems(companyId: number, webPage?: number | undefined): Observable<WebPageDropDownItem[]> {
        let url_ = this.baseUrl + "/api/Company/Company/{companyId}/WebPageDropDownItems?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (webPage === null)
            throw new Error("The parameter 'webPage' cannot be null.");
        else if (webPage !== undefined)
            url_ += "webPage=" + encodeURIComponent("" + webPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWebPageDropDownItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWebPageDropDownItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebPageDropDownItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebPageDropDownItem[]>;
        }));
    }

    protected processGetWebPageDropDownItems(response: HttpResponseBase): Observable<WebPageDropDownItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebPageDropDownItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebPageDropDownItem[]>(null as any);
    }
}

export interface IFaceDeviceClient {
    /**
     * @param searchModel_FaceTerminalNo (optional) 
     * @param searchModel_DeviceId (optional) 
     * @param searchModel_DeviceStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceDevice(searchModel_FaceTerminalNo?: string | undefined, searchModel_DeviceId?: string | undefined, searchModel_DeviceStatus?: FaceDeviceStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceDeviceListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceDevice(body?: UpdateFaceDevice | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    faceDeviceRegister(body?: FaceDeviceRegister | undefined): Observable<IdResponse>;
    /**
     * @return Success
     */
    getFaceDevice(id: number): Observable<FaceDeviceDetails>;
    /**
     * @return Success
     */
    getFaceDeviceLogs(faceDeviceId: number): Observable<ActionLogListItem[]>;
    exportDevices(faceTerminalNo?: string | undefined, deviceId?: string | undefined, deviceStatus?: FaceDeviceStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class FaceDeviceClient implements IFaceDeviceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_FaceTerminalNo (optional) 
     * @param searchModel_DeviceId (optional) 
     * @param searchModel_DeviceStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceDevice(searchModel_FaceTerminalNo?: string | undefined, searchModel_DeviceId?: string | undefined, searchModel_DeviceStatus?: FaceDeviceStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceDeviceListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/FaceDevice?";
        if (searchModel_FaceTerminalNo === null)
            throw new Error("The parameter 'searchModel_FaceTerminalNo' cannot be null.");
        else if (searchModel_FaceTerminalNo !== undefined)
            url_ += "SearchModel.FaceTerminalNo=" + encodeURIComponent("" + searchModel_FaceTerminalNo) + "&";
        if (searchModel_DeviceId === null)
            throw new Error("The parameter 'searchModel_DeviceId' cannot be null.");
        else if (searchModel_DeviceId !== undefined)
            url_ += "SearchModel.DeviceId=" + encodeURIComponent("" + searchModel_DeviceId) + "&";
        if (searchModel_DeviceStatus === null)
            throw new Error("The parameter 'searchModel_DeviceStatus' cannot be null.");
        else if (searchModel_DeviceStatus !== undefined)
            url_ += "SearchModel.DeviceStatus=" + encodeURIComponent("" + searchModel_DeviceStatus) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryFaceDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryFaceDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceDeviceListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceDeviceListItemPagingResponse>;
        }));
    }

    protected processQueryFaceDevice(response: HttpResponseBase): Observable<FaceDeviceListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceDeviceListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceDeviceListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceDevice(body?: UpdateFaceDevice | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FaceDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFaceDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFaceDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveFaceDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    faceDeviceRegister(body?: FaceDeviceRegister | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/FaceDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFaceDeviceRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFaceDeviceRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processFaceDeviceRegister(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return Success
     */
    getFaceDevice(id: number): Observable<FaceDeviceDetails> {
        let url_ = this.baseUrl + "/api/FaceDevice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceDeviceDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceDeviceDetails>;
        }));
    }

    protected processGetFaceDevice(response: HttpResponseBase): Observable<FaceDeviceDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceDeviceDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceDeviceDetails>(null as any);
    }

    /**
     * @return Success
     */
    getFaceDeviceLogs(faceDeviceId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/FaceDevice/{faceDeviceId}/Logs";
        if (faceDeviceId === undefined || faceDeviceId === null)
            throw new Error("The parameter 'faceDeviceId' must be defined.");
        url_ = url_.replace("{faceDeviceId}", encodeURIComponent("" + faceDeviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceDeviceLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceDeviceLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetFaceDeviceLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    exportDevices(faceTerminalNo?: string | undefined, deviceId?: string | undefined, deviceStatus?: FaceDeviceStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FaceDevice/Export?";
        if (faceTerminalNo === null)
            throw new Error("The parameter 'faceTerminalNo' cannot be null.");
        else if (faceTerminalNo !== undefined)
            url_ += "FaceTerminalNo=" + encodeURIComponent("" + faceTerminalNo) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (deviceStatus === null)
            throw new Error("The parameter 'deviceStatus' cannot be null.");
        else if (deviceStatus !== undefined)
            url_ += "DeviceStatus=" + encodeURIComponent("" + deviceStatus) + "&";
        if (dateCreatedFrom === null)
            throw new Error("The parameter 'dateCreatedFrom' cannot be null.");
        else if (dateCreatedFrom !== undefined)
            url_ += "DateCreatedFrom=" + encodeURIComponent(dateCreatedFrom ? "" + dateCreatedFrom.toISOString() : "") + "&";
        if (dateCreatedTo === null)
            throw new Error("The parameter 'dateCreatedTo' cannot be null.");
        else if (dateCreatedTo !== undefined)
            url_ += "DateCreatedTo=" + encodeURIComponent(dateCreatedTo ? "" + dateCreatedTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportDevices(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IFaceMerchantClient {
    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceMerchants(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceMerchantListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceMerchant(body?: UpdateFaceMerchant | undefined): Observable<void>;
    /**
     * @return Success
     */
    getFaceMerchant(id: number): Observable<FaceMerchantDetails>;
    /**
     * @return Success
     */
    getFaceMerchantLogs(faceMerchantId: number): Observable<ActionLogListItem[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addFaceMerchantToCompany(companyId: number, body?: FaceMerchantRegister | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    changeFaceMerchantStatus(id: number, status: ServiceStatus): Observable<void>;
}

@Injectable()
export class FaceMerchantClient implements IFaceMerchantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceMerchants(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceMerchantListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/FaceMerchant?";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryFaceMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryFaceMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceMerchantListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceMerchantListItemPagingResponse>;
        }));
    }

    protected processQueryFaceMerchants(response: HttpResponseBase): Observable<FaceMerchantListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceMerchantListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceMerchantListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceMerchant(body?: UpdateFaceMerchant | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FaceMerchant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFaceMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFaceMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveFaceMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getFaceMerchant(id: number): Observable<FaceMerchantDetails> {
        let url_ = this.baseUrl + "/api/FaceMerchant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceMerchantDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceMerchantDetails>;
        }));
    }

    protected processGetFaceMerchant(response: HttpResponseBase): Observable<FaceMerchantDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceMerchantDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceMerchantDetails>(null as any);
    }

    /**
     * @return Success
     */
    getFaceMerchantLogs(faceMerchantId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/FaceMerchant/{faceMerchantId}/Logs";
        if (faceMerchantId === undefined || faceMerchantId === null)
            throw new Error("The parameter 'faceMerchantId' must be defined.");
        url_ = url_.replace("{faceMerchantId}", encodeURIComponent("" + faceMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceMerchantLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceMerchantLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetFaceMerchantLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addFaceMerchantToCompany(companyId: number, body?: FaceMerchantRegister | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/FaceMerchant/Company/{companyId}/FaceMerchantRegister";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFaceMerchantToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFaceMerchantToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddFaceMerchantToCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    changeFaceMerchantStatus(id: number, status: ServiceStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/FaceMerchant/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeFaceMerchantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeFaceMerchantStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeFaceMerchantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IFaceTerminalClient {
    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_DeviceId (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_FaceTerminalStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceTerminal(searchModel_CompanyName?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_TerminalNo?: string | undefined, searchModel_DeviceId?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_FaceTerminalStatus?: FaceTerminalStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceTerminalListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceTerminal(body?: UpdateFaceTerminal | undefined): Observable<void>;
    /**
     * @return Success
     */
    getFaceTerminal(id: number): Observable<FaceTerminalDetails>;
    /**
     * @return Success
     */
    getFaceTerminalLogs(faceMerchantId: number): Observable<ActionLogListItem[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addFaceTerminalRegister(merchantExternalId: string, body?: FaceTerminalRegister | undefined): Observable<IdResponse>;
    /**
     * @return Success
     */
    isMerchantNotDeclined(id: number): Observable<boolean>;
    exportTerminals(companyName?: string | undefined, tradeName?: string | undefined, terminalNo?: string | undefined, deviceId?: string | undefined, merchantExternalId?: string | undefined, companyIdentificationNumber?: string | undefined, faceTerminalStatus?: FaceTerminalStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class FaceTerminalClient implements IFaceTerminalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_DeviceId (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_FaceTerminalStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryFaceTerminal(searchModel_CompanyName?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_TerminalNo?: string | undefined, searchModel_DeviceId?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_FaceTerminalStatus?: FaceTerminalStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<FaceTerminalListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/FaceTerminal?";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_TerminalNo === null)
            throw new Error("The parameter 'searchModel_TerminalNo' cannot be null.");
        else if (searchModel_TerminalNo !== undefined)
            url_ += "SearchModel.TerminalNo=" + encodeURIComponent("" + searchModel_TerminalNo) + "&";
        if (searchModel_DeviceId === null)
            throw new Error("The parameter 'searchModel_DeviceId' cannot be null.");
        else if (searchModel_DeviceId !== undefined)
            url_ += "SearchModel.DeviceId=" + encodeURIComponent("" + searchModel_DeviceId) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_FaceTerminalStatus === null)
            throw new Error("The parameter 'searchModel_FaceTerminalStatus' cannot be null.");
        else if (searchModel_FaceTerminalStatus !== undefined)
            url_ += "SearchModel.FaceTerminalStatus=" + encodeURIComponent("" + searchModel_FaceTerminalStatus) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryFaceTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryFaceTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceTerminalListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceTerminalListItemPagingResponse>;
        }));
    }

    protected processQueryFaceTerminal(response: HttpResponseBase): Observable<FaceTerminalListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceTerminalListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceTerminalListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveFaceTerminal(body?: UpdateFaceTerminal | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FaceTerminal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFaceTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFaceTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveFaceTerminal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getFaceTerminal(id: number): Observable<FaceTerminalDetails> {
        let url_ = this.baseUrl + "/api/FaceTerminal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FaceTerminalDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FaceTerminalDetails>;
        }));
    }

    protected processGetFaceTerminal(response: HttpResponseBase): Observable<FaceTerminalDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FaceTerminalDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceTerminalDetails>(null as any);
    }

    /**
     * @return Success
     */
    getFaceTerminalLogs(faceMerchantId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/FaceTerminal/{faceMerchantId}/Logs";
        if (faceMerchantId === undefined || faceMerchantId === null)
            throw new Error("The parameter 'faceMerchantId' must be defined.");
        url_ = url_.replace("{faceMerchantId}", encodeURIComponent("" + faceMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceTerminalLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceTerminalLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetFaceTerminalLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addFaceTerminalRegister(merchantExternalId: string, body?: FaceTerminalRegister | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/FaceTerminal/FaceMerchant/{merchantExternalId}/FaceTerminalRegister";
        if (merchantExternalId === undefined || merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' must be defined.");
        url_ = url_.replace("{merchantExternalId}", encodeURIComponent("" + merchantExternalId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFaceTerminalRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFaceTerminalRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddFaceTerminalRegister(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return Success
     */
    isMerchantNotDeclined(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/FaceTerminal/{id}/IsMerchantNotDeclined";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsMerchantNotDeclined(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsMerchantNotDeclined(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsMerchantNotDeclined(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    exportTerminals(companyName?: string | undefined, tradeName?: string | undefined, terminalNo?: string | undefined, deviceId?: string | undefined, merchantExternalId?: string | undefined, companyIdentificationNumber?: string | undefined, faceTerminalStatus?: FaceTerminalStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FaceTerminal/Export?";
        if (companyName === null)
            throw new Error("The parameter 'companyName' cannot be null.");
        else if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (tradeName === null)
            throw new Error("The parameter 'tradeName' cannot be null.");
        else if (tradeName !== undefined)
            url_ += "TradeName=" + encodeURIComponent("" + tradeName) + "&";
        if (terminalNo === null)
            throw new Error("The parameter 'terminalNo' cannot be null.");
        else if (terminalNo !== undefined)
            url_ += "TerminalNo=" + encodeURIComponent("" + terminalNo) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (companyIdentificationNumber === null)
            throw new Error("The parameter 'companyIdentificationNumber' cannot be null.");
        else if (companyIdentificationNumber !== undefined)
            url_ += "CompanyIdentificationNumber=" + encodeURIComponent("" + companyIdentificationNumber) + "&";
        if (faceTerminalStatus === null)
            throw new Error("The parameter 'faceTerminalStatus' cannot be null.");
        else if (faceTerminalStatus !== undefined)
            url_ += "FaceTerminalStatus=" + encodeURIComponent("" + faceTerminalStatus) + "&";
        if (dateCreatedFrom === null)
            throw new Error("The parameter 'dateCreatedFrom' cannot be null.");
        else if (dateCreatedFrom !== undefined)
            url_ += "DateCreatedFrom=" + encodeURIComponent(dateCreatedFrom ? "" + dateCreatedFrom.toISOString() : "") + "&";
        if (dateCreatedTo === null)
            throw new Error("The parameter 'dateCreatedTo' cannot be null.");
        else if (dateCreatedTo !== undefined)
            url_ += "DateCreatedTo=" + encodeURIComponent(dateCreatedTo ? "" + dateCreatedTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTerminals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTerminals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportTerminals(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IMerchantLogosClient {
    /**
     * @param searchModel_WebAddress (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryMerchantLogos(searchModel_WebAddress?: string | undefined, searchModel_Status?: LogoStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<MerchantLogoItemPagingResponse>;
    /**
     * @param paymentMerchantId (optional) 
     * @param comment (optional) 
     * @return Success
     */
    approveMerchantLogo(logoId: number, paymentMerchantId?: number | undefined, comment?: string | undefined): Observable<ApiResponse>;
    /**
     * @param paymentMerchantId (optional) 
     * @param comment (optional) 
     * @return Success
     */
    declineMerchantLogo(logoId: number, paymentMerchantId?: number | undefined, comment?: string | undefined): Observable<ApiResponse>;
    /**
     * @return Success
     */
    getMerchantLogoLogs(logoId: number): Observable<ActionLogListItem[]>;
}

@Injectable()
export class MerchantLogosClient implements IMerchantLogosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_WebAddress (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryMerchantLogos(searchModel_WebAddress?: string | undefined, searchModel_Status?: LogoStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<MerchantLogoItemPagingResponse> {
        let url_ = this.baseUrl + "/api/MerchantLogos?";
        if (searchModel_WebAddress === null)
            throw new Error("The parameter 'searchModel_WebAddress' cannot be null.");
        else if (searchModel_WebAddress !== undefined)
            url_ += "SearchModel.WebAddress=" + encodeURIComponent("" + searchModel_WebAddress) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryMerchantLogos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryMerchantLogos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantLogoItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantLogoItemPagingResponse>;
        }));
    }

    protected processQueryMerchantLogos(response: HttpResponseBase): Observable<MerchantLogoItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MerchantLogoItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MerchantLogoItemPagingResponse>(null as any);
    }

    /**
     * @param paymentMerchantId (optional) 
     * @param comment (optional) 
     * @return Success
     */
    approveMerchantLogo(logoId: number, paymentMerchantId?: number | undefined, comment?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/MerchantLogos/{logoId}/Approve?";
        if (logoId === undefined || logoId === null)
            throw new Error("The parameter 'logoId' must be defined.");
        url_ = url_.replace("{logoId}", encodeURIComponent("" + logoId));
        if (paymentMerchantId === null)
            throw new Error("The parameter 'paymentMerchantId' cannot be null.");
        else if (paymentMerchantId !== undefined)
            url_ += "paymentMerchantId=" + encodeURIComponent("" + paymentMerchantId) + "&";
        if (comment === null)
            throw new Error("The parameter 'comment' cannot be null.");
        else if (comment !== undefined)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveMerchantLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveMerchantLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processApproveMerchantLogo(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param paymentMerchantId (optional) 
     * @param comment (optional) 
     * @return Success
     */
    declineMerchantLogo(logoId: number, paymentMerchantId?: number | undefined, comment?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/MerchantLogos/{logoId}/Decline?";
        if (logoId === undefined || logoId === null)
            throw new Error("The parameter 'logoId' must be defined.");
        url_ = url_.replace("{logoId}", encodeURIComponent("" + logoId));
        if (paymentMerchantId === null)
            throw new Error("The parameter 'paymentMerchantId' cannot be null.");
        else if (paymentMerchantId !== undefined)
            url_ += "paymentMerchantId=" + encodeURIComponent("" + paymentMerchantId) + "&";
        if (comment === null)
            throw new Error("The parameter 'comment' cannot be null.");
        else if (comment !== undefined)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeclineMerchantLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeclineMerchantLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeclineMerchantLogo(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    getMerchantLogoLogs(logoId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/MerchantLogos/{logoId}/Logs";
        if (logoId === undefined || logoId === null)
            throw new Error("The parameter 'logoId' must be defined.");
        url_ = url_.replace("{logoId}", encodeURIComponent("" + logoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantLogoLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantLogoLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetMerchantLogoLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }
}

export interface IPayByLinkBasketsClient {
    /**
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Name (optional) 
     * @param searchModel_Code (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_ExpirationDate_From (optional) 
     * @param searchModel_ExpirationDate_To (optional) 
     * @param searchModel_Creator (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryBaskets(searchModel_MerchantTradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Name?: string | undefined, searchModel_Code?: string | undefined, searchModel_Currency?: Currency | undefined, searchModel_Amount?: number | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_Status?: number | undefined, searchModel_ExpirationDate_From?: moment.Moment | undefined, searchModel_ExpirationDate_To?: moment.Moment | undefined, searchModel_Creator?: CreatorType | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<BasketListItemPagingResponse>;
    /**
     * @return Success
     */
    getBasket(id: number): Observable<BasketDetails>;
    /**
     * @return Success
     */
    getBasketStatuses(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getCreatorTypes(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getBasketLogs(basketId: number): Observable<ActionLogListItem[]>;
    exportBaskets(merchantTradeName?: string | undefined, merchantExternalId?: string | undefined, name?: string | undefined, code?: string | undefined, currency?: Currency | undefined, amount?: number | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, status?: number | undefined, expirationDate_From?: moment.Moment | undefined, expirationDate_To?: moment.Moment | undefined, creator?: CreatorType | undefined): Observable<FileResponse>;
}

@Injectable()
export class PayByLinkBasketsClient implements IPayByLinkBasketsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Name (optional) 
     * @param searchModel_Code (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_ExpirationDate_From (optional) 
     * @param searchModel_ExpirationDate_To (optional) 
     * @param searchModel_Creator (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryBaskets(searchModel_MerchantTradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Name?: string | undefined, searchModel_Code?: string | undefined, searchModel_Currency?: Currency | undefined, searchModel_Amount?: number | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_Status?: number | undefined, searchModel_ExpirationDate_From?: moment.Moment | undefined, searchModel_ExpirationDate_To?: moment.Moment | undefined, searchModel_Creator?: CreatorType | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<BasketListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets?";
        if (searchModel_MerchantTradeName === null)
            throw new Error("The parameter 'searchModel_MerchantTradeName' cannot be null.");
        else if (searchModel_MerchantTradeName !== undefined)
            url_ += "SearchModel.MerchantTradeName=" + encodeURIComponent("" + searchModel_MerchantTradeName) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_Name === null)
            throw new Error("The parameter 'searchModel_Name' cannot be null.");
        else if (searchModel_Name !== undefined)
            url_ += "SearchModel.Name=" + encodeURIComponent("" + searchModel_Name) + "&";
        if (searchModel_Code === null)
            throw new Error("The parameter 'searchModel_Code' cannot be null.");
        else if (searchModel_Code !== undefined)
            url_ += "SearchModel.Code=" + encodeURIComponent("" + searchModel_Code) + "&";
        if (searchModel_Currency === null)
            throw new Error("The parameter 'searchModel_Currency' cannot be null.");
        else if (searchModel_Currency !== undefined)
            url_ += "SearchModel.Currency=" + encodeURIComponent("" + searchModel_Currency) + "&";
        if (searchModel_Amount === null)
            throw new Error("The parameter 'searchModel_Amount' cannot be null.");
        else if (searchModel_Amount !== undefined)
            url_ += "SearchModel.Amount=" + encodeURIComponent("" + searchModel_Amount) + "&";
        if (searchModel_DateCreated_From === null)
            throw new Error("The parameter 'searchModel_DateCreated_From' cannot be null.");
        else if (searchModel_DateCreated_From !== undefined)
            url_ += "SearchModel.DateCreated.From=" + encodeURIComponent(searchModel_DateCreated_From ? "" + searchModel_DateCreated_From.toISOString() : "") + "&";
        if (searchModel_DateCreated_To === null)
            throw new Error("The parameter 'searchModel_DateCreated_To' cannot be null.");
        else if (searchModel_DateCreated_To !== undefined)
            url_ += "SearchModel.DateCreated.To=" + encodeURIComponent(searchModel_DateCreated_To ? "" + searchModel_DateCreated_To.toISOString() : "") + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_ExpirationDate_From === null)
            throw new Error("The parameter 'searchModel_ExpirationDate_From' cannot be null.");
        else if (searchModel_ExpirationDate_From !== undefined)
            url_ += "SearchModel.ExpirationDate.From=" + encodeURIComponent(searchModel_ExpirationDate_From ? "" + searchModel_ExpirationDate_From.toISOString() : "") + "&";
        if (searchModel_ExpirationDate_To === null)
            throw new Error("The parameter 'searchModel_ExpirationDate_To' cannot be null.");
        else if (searchModel_ExpirationDate_To !== undefined)
            url_ += "SearchModel.ExpirationDate.To=" + encodeURIComponent(searchModel_ExpirationDate_To ? "" + searchModel_ExpirationDate_To.toISOString() : "") + "&";
        if (searchModel_Creator === null)
            throw new Error("The parameter 'searchModel_Creator' cannot be null.");
        else if (searchModel_Creator !== undefined)
            url_ += "SearchModel.Creator=" + encodeURIComponent("" + searchModel_Creator) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryBaskets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryBaskets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketListItemPagingResponse>;
        }));
    }

    protected processQueryBaskets(response: HttpResponseBase): Observable<BasketListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasketListItemPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    getBasket(id: number): Observable<BasketDetails> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketDetails>;
        }));
    }

    protected processGetBasket(response: HttpResponseBase): Observable<BasketDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasketDetails>(null as any);
    }

    /**
     * @return Success
     */
    getBasketStatuses(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets/Statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasketStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasketStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetBasketStatuses(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getCreatorTypes(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets/CreatorTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreatorTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreatorTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetCreatorTypes(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getBasketLogs(basketId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets/{basketId}/Logs";
        if (basketId === undefined || basketId === null)
            throw new Error("The parameter 'basketId' must be defined.");
        url_ = url_.replace("{basketId}", encodeURIComponent("" + basketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasketLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasketLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetBasketLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    exportBaskets(merchantTradeName?: string | undefined, merchantExternalId?: string | undefined, name?: string | undefined, code?: string | undefined, currency?: Currency | undefined, amount?: number | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, status?: number | undefined, expirationDate_From?: moment.Moment | undefined, expirationDate_To?: moment.Moment | undefined, creator?: CreatorType | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PayByLinkBaskets/Export?";
        if (merchantTradeName === null)
            throw new Error("The parameter 'merchantTradeName' cannot be null.");
        else if (merchantTradeName !== undefined)
            url_ += "MerchantTradeName=" + encodeURIComponent("" + merchantTradeName) + "&";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (currency === null)
            throw new Error("The parameter 'currency' cannot be null.");
        else if (currency !== undefined)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent(dateCreated_From ? "" + dateCreated_From.toISOString() : "") + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent(dateCreated_To ? "" + dateCreated_To.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (expirationDate_From === null)
            throw new Error("The parameter 'expirationDate_From' cannot be null.");
        else if (expirationDate_From !== undefined)
            url_ += "ExpirationDate.From=" + encodeURIComponent(expirationDate_From ? "" + expirationDate_From.toISOString() : "") + "&";
        if (expirationDate_To === null)
            throw new Error("The parameter 'expirationDate_To' cannot be null.");
        else if (expirationDate_To !== undefined)
            url_ += "ExpirationDate.To=" + encodeURIComponent(expirationDate_To ? "" + expirationDate_To.toISOString() : "") + "&";
        if (creator === null)
            throw new Error("The parameter 'creator' cannot be null.");
        else if (creator !== undefined)
            url_ += "Creator=" + encodeURIComponent("" + creator) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportBaskets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportBaskets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportBaskets(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IPayByLinkProductsClient {
    /**
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Name (optional) 
     * @param searchModel_Code (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_ProductType (optional) 
     * @param searchModel_MaxQuantityPerBuy (optional) 
     * @param searchModel_MaxTotalQuantity (optional) 
     * @param searchModel_IsReusable (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryProducts(searchModel_MerchantTradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Name?: string | undefined, searchModel_Code?: string | undefined, searchModel_Currency?: Currency | undefined, searchModel_Amount?: number | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_Status?: number | undefined, searchModel_ProductType?: ProductType | undefined, searchModel_MaxQuantityPerBuy?: number | undefined, searchModel_MaxTotalQuantity?: number | undefined, searchModel_IsReusable?: boolean | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ProductListItemPagingResponse>;
    /**
     * @return Success
     */
    getProduct(id: number): Observable<ProductDetails>;
    getProductImage(fileName?: string | undefined): Observable<FileResponse>;
    /**
     * @return Success
     */
    getProductStatuses(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getProductTypes(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getProductLogs(productId: number): Observable<ActionLogListItem[]>;
    exportProducts(merchantTradeName?: string | undefined, merchantExternalId?: string | undefined, name?: string | undefined, code?: string | undefined, currency?: Currency | undefined, amount?: number | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, status?: number | undefined, productType?: ProductType | undefined, maxQuantityPerBuy?: number | undefined, maxTotalQuantity?: number | undefined, isReusable?: boolean | undefined): Observable<FileResponse>;
}

@Injectable()
export class PayByLinkProductsClient implements IPayByLinkProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_Name (optional) 
     * @param searchModel_Code (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_ProductType (optional) 
     * @param searchModel_MaxQuantityPerBuy (optional) 
     * @param searchModel_MaxTotalQuantity (optional) 
     * @param searchModel_IsReusable (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryProducts(searchModel_MerchantTradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_Name?: string | undefined, searchModel_Code?: string | undefined, searchModel_Currency?: Currency | undefined, searchModel_Amount?: number | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_Status?: number | undefined, searchModel_ProductType?: ProductType | undefined, searchModel_MaxQuantityPerBuy?: number | undefined, searchModel_MaxTotalQuantity?: number | undefined, searchModel_IsReusable?: boolean | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ProductListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts?";
        if (searchModel_MerchantTradeName === null)
            throw new Error("The parameter 'searchModel_MerchantTradeName' cannot be null.");
        else if (searchModel_MerchantTradeName !== undefined)
            url_ += "SearchModel.MerchantTradeName=" + encodeURIComponent("" + searchModel_MerchantTradeName) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_Name === null)
            throw new Error("The parameter 'searchModel_Name' cannot be null.");
        else if (searchModel_Name !== undefined)
            url_ += "SearchModel.Name=" + encodeURIComponent("" + searchModel_Name) + "&";
        if (searchModel_Code === null)
            throw new Error("The parameter 'searchModel_Code' cannot be null.");
        else if (searchModel_Code !== undefined)
            url_ += "SearchModel.Code=" + encodeURIComponent("" + searchModel_Code) + "&";
        if (searchModel_Currency === null)
            throw new Error("The parameter 'searchModel_Currency' cannot be null.");
        else if (searchModel_Currency !== undefined)
            url_ += "SearchModel.Currency=" + encodeURIComponent("" + searchModel_Currency) + "&";
        if (searchModel_Amount === null)
            throw new Error("The parameter 'searchModel_Amount' cannot be null.");
        else if (searchModel_Amount !== undefined)
            url_ += "SearchModel.Amount=" + encodeURIComponent("" + searchModel_Amount) + "&";
        if (searchModel_DateCreated_From === null)
            throw new Error("The parameter 'searchModel_DateCreated_From' cannot be null.");
        else if (searchModel_DateCreated_From !== undefined)
            url_ += "SearchModel.DateCreated.From=" + encodeURIComponent(searchModel_DateCreated_From ? "" + searchModel_DateCreated_From.toISOString() : "") + "&";
        if (searchModel_DateCreated_To === null)
            throw new Error("The parameter 'searchModel_DateCreated_To' cannot be null.");
        else if (searchModel_DateCreated_To !== undefined)
            url_ += "SearchModel.DateCreated.To=" + encodeURIComponent(searchModel_DateCreated_To ? "" + searchModel_DateCreated_To.toISOString() : "") + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_ProductType === null)
            throw new Error("The parameter 'searchModel_ProductType' cannot be null.");
        else if (searchModel_ProductType !== undefined)
            url_ += "SearchModel.ProductType=" + encodeURIComponent("" + searchModel_ProductType) + "&";
        if (searchModel_MaxQuantityPerBuy === null)
            throw new Error("The parameter 'searchModel_MaxQuantityPerBuy' cannot be null.");
        else if (searchModel_MaxQuantityPerBuy !== undefined)
            url_ += "SearchModel.MaxQuantityPerBuy=" + encodeURIComponent("" + searchModel_MaxQuantityPerBuy) + "&";
        if (searchModel_MaxTotalQuantity === null)
            throw new Error("The parameter 'searchModel_MaxTotalQuantity' cannot be null.");
        else if (searchModel_MaxTotalQuantity !== undefined)
            url_ += "SearchModel.MaxTotalQuantity=" + encodeURIComponent("" + searchModel_MaxTotalQuantity) + "&";
        if (searchModel_IsReusable === null)
            throw new Error("The parameter 'searchModel_IsReusable' cannot be null.");
        else if (searchModel_IsReusable !== undefined)
            url_ += "SearchModel.IsReusable=" + encodeURIComponent("" + searchModel_IsReusable) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductListItemPagingResponse>;
        }));
    }

    protected processQueryProducts(response: HttpResponseBase): Observable<ProductListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItemPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    getProduct(id: number): Observable<ProductDetails> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDetails>;
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDetails>(null as any);
    }

    getProductImage(fileName?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/Image?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    getProductStatuses(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/Statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetProductStatuses(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getProductTypes(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetProductTypes(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getProductLogs(productId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/{productId}/Logs";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetProductLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    exportProducts(merchantTradeName?: string | undefined, merchantExternalId?: string | undefined, name?: string | undefined, code?: string | undefined, currency?: Currency | undefined, amount?: number | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, status?: number | undefined, productType?: ProductType | undefined, maxQuantityPerBuy?: number | undefined, maxTotalQuantity?: number | undefined, isReusable?: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PayByLinkProducts/Export?";
        if (merchantTradeName === null)
            throw new Error("The parameter 'merchantTradeName' cannot be null.");
        else if (merchantTradeName !== undefined)
            url_ += "MerchantTradeName=" + encodeURIComponent("" + merchantTradeName) + "&";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (currency === null)
            throw new Error("The parameter 'currency' cannot be null.");
        else if (currency !== undefined)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent(dateCreated_From ? "" + dateCreated_From.toISOString() : "") + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent(dateCreated_To ? "" + dateCreated_To.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (productType === null)
            throw new Error("The parameter 'productType' cannot be null.");
        else if (productType !== undefined)
            url_ += "ProductType=" + encodeURIComponent("" + productType) + "&";
        if (maxQuantityPerBuy === null)
            throw new Error("The parameter 'maxQuantityPerBuy' cannot be null.");
        else if (maxQuantityPerBuy !== undefined)
            url_ += "MaxQuantityPerBuy=" + encodeURIComponent("" + maxQuantityPerBuy) + "&";
        if (maxTotalQuantity === null)
            throw new Error("The parameter 'maxTotalQuantity' cannot be null.");
        else if (maxTotalQuantity !== undefined)
            url_ += "MaxTotalQuantity=" + encodeURIComponent("" + maxTotalQuantity) + "&";
        if (isReusable === null)
            throw new Error("The parameter 'isReusable' cannot be null.");
        else if (isReusable !== undefined)
            url_ += "IsReusable=" + encodeURIComponent("" + isReusable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportProducts(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IPosQRClient {
    /**
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_ServiceStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryPosQR(searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_ServiceStatus?: ServiceStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PosQRListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    updatePosQRMerchant(body?: UpdatePosQR | undefined): Observable<void>;
    /**
     * @return Success
     */
    getPosQRMerchant(id: number): Observable<PosQRDetails>;
    /**
     * @return Success
     */
    getPosQrMerchantLogs(posQrMerchantId: number): Observable<ActionLogListItem[]>;
    /**
     * @return Success
     */
    addPosQRMerchantToCompany(companyId: number, body: RegisterPosQRMerchantRequest): Observable<IdResponse>;
    /**
     * @return No Content
     */
    changePosQRMerchantStatus(id: number, status: ServiceStatus): Observable<void>;
    /**
     * @return Success
     */
    clientSecret(merchantId: number): Observable<ClientSecretModel>;
    exportPosMerchants(merchantExternalId?: string | undefined, tradeName?: string | undefined, companyIdentificationNumber?: string | undefined, serviceStatus?: ServiceStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class PosQRClient implements IPosQRClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_ServiceStatus (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryPosQR(searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_ServiceStatus?: ServiceStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PosQRListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/PosQR?";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_ServiceStatus === null)
            throw new Error("The parameter 'searchModel_ServiceStatus' cannot be null.");
        else if (searchModel_ServiceStatus !== undefined)
            url_ += "SearchModel.ServiceStatus=" + encodeURIComponent("" + searchModel_ServiceStatus) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryPosQR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryPosQR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosQRListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosQRListItemPagingResponse>;
        }));
    }

    protected processQueryPosQR(response: HttpResponseBase): Observable<PosQRListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PosQRListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosQRListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    updatePosQRMerchant(body?: UpdatePosQR | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PosQR";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosQRMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosQRMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePosQRMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPosQRMerchant(id: number): Observable<PosQRDetails> {
        let url_ = this.baseUrl + "/api/PosQR/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosQRMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosQRMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosQRDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosQRDetails>;
        }));
    }

    protected processGetPosQRMerchant(response: HttpResponseBase): Observable<PosQRDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PosQRDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosQRDetails>(null as any);
    }

    /**
     * @return Success
     */
    getPosQrMerchantLogs(posQrMerchantId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/PosQR/{posQrMerchantId}/Logs";
        if (posQrMerchantId === undefined || posQrMerchantId === null)
            throw new Error("The parameter 'posQrMerchantId' must be defined.");
        url_ = url_.replace("{posQrMerchantId}", encodeURIComponent("" + posQrMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosQrMerchantLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosQrMerchantLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetPosQrMerchantLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @return Success
     */
    addPosQRMerchantToCompany(companyId: number, body: RegisterPosQRMerchantRequest): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/PosQR/{companyId}/PosQRMerchantRegister";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPosQRMerchantToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPosQRMerchantToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddPosQRMerchantToCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    changePosQRMerchantStatus(id: number, status: ServiceStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/PosQR/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePosQRMerchantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePosQRMerchantStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePosQRMerchantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientSecret(merchantId: number): Observable<ClientSecretModel> {
        let url_ = this.baseUrl + "/api/PosQR/{merchantId}/client-secret";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSecret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSecret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSecretModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSecretModel>;
        }));
    }

    protected processClientSecret(response: HttpResponseBase): Observable<ClientSecretModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClientSecretModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSecretModel>(null as any);
    }

    exportPosMerchants(merchantExternalId?: string | undefined, tradeName?: string | undefined, companyIdentificationNumber?: string | undefined, serviceStatus?: ServiceStatus | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PosQR/Export?";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (tradeName === null)
            throw new Error("The parameter 'tradeName' cannot be null.");
        else if (tradeName !== undefined)
            url_ += "TradeName=" + encodeURIComponent("" + tradeName) + "&";
        if (companyIdentificationNumber === null)
            throw new Error("The parameter 'companyIdentificationNumber' cannot be null.");
        else if (companyIdentificationNumber !== undefined)
            url_ += "CompanyIdentificationNumber=" + encodeURIComponent("" + companyIdentificationNumber) + "&";
        if (serviceStatus === null)
            throw new Error("The parameter 'serviceStatus' cannot be null.");
        else if (serviceStatus !== undefined)
            url_ += "ServiceStatus=" + encodeURIComponent("" + serviceStatus) + "&";
        if (dateCreatedFrom === null)
            throw new Error("The parameter 'dateCreatedFrom' cannot be null.");
        else if (dateCreatedFrom !== undefined)
            url_ += "DateCreatedFrom=" + encodeURIComponent(dateCreatedFrom ? "" + dateCreatedFrom.toISOString() : "") + "&";
        if (dateCreatedTo === null)
            throw new Error("The parameter 'dateCreatedTo' cannot be null.");
        else if (dateCreatedTo !== undefined)
            url_ += "DateCreatedTo=" + encodeURIComponent(dateCreatedTo ? "" + dateCreatedTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPosMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPosMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportPosMerchants(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IPosQRTerminalClient {
    /**
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_PhysicalTerminalNo (optional) 
     * @param searchModel_IsBnplEnabled (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryPosQRTerminal(searchModel_TerminalNo?: string | undefined, searchModel_PhysicalTerminalNo?: string | undefined, searchModel_IsBnplEnabled?: boolean | undefined, searchModel_Status?: PosQRTerminalStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_CompanyName?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ListItemPosQRTerminalPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    updatePosQRTerminal(body?: UpdatePosQRTerminal | undefined): Observable<void>;
    /**
     * @return Success
     */
    getPosQRTerminal(id: number): Observable<DetailsPosQRTerminal>;
    /**
     * @return Success
     */
    getPosQRTerminalLogs(posQrTerminalId: number): Observable<ActionLogListItem[]>;
    /**
     * @return No Content
     */
    changePosQRTerminalStatus(id: number, status: PosQRTerminalStatus): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addPosQRTerminalRegister(merchantExternalId: string, body?: RegisterPosQRTerminal | undefined): Observable<IdResponse>;
    /**
     * @return Success
     */
    isPosQRMerchantAccepted(merchantExternalId: string): Observable<IsMerchantAcceptedDto>;
}

@Injectable()
export class PosQRTerminalClient implements IPosQRTerminalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_PhysicalTerminalNo (optional) 
     * @param searchModel_IsBnplEnabled (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryPosQRTerminal(searchModel_TerminalNo?: string | undefined, searchModel_PhysicalTerminalNo?: string | undefined, searchModel_IsBnplEnabled?: boolean | undefined, searchModel_Status?: PosQRTerminalStatus | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, searchModel_CompanyName?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<ListItemPosQRTerminalPagingResponse> {
        let url_ = this.baseUrl + "/api/PosQRTerminal?";
        if (searchModel_TerminalNo === null)
            throw new Error("The parameter 'searchModel_TerminalNo' cannot be null.");
        else if (searchModel_TerminalNo !== undefined)
            url_ += "SearchModel.TerminalNo=" + encodeURIComponent("" + searchModel_TerminalNo) + "&";
        if (searchModel_PhysicalTerminalNo === null)
            throw new Error("The parameter 'searchModel_PhysicalTerminalNo' cannot be null.");
        else if (searchModel_PhysicalTerminalNo !== undefined)
            url_ += "SearchModel.PhysicalTerminalNo=" + encodeURIComponent("" + searchModel_PhysicalTerminalNo) + "&";
        if (searchModel_IsBnplEnabled === null)
            throw new Error("The parameter 'searchModel_IsBnplEnabled' cannot be null.");
        else if (searchModel_IsBnplEnabled !== undefined)
            url_ += "SearchModel.IsBnplEnabled=" + encodeURIComponent("" + searchModel_IsBnplEnabled) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryPosQRTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryPosQRTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemPosQRTerminalPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemPosQRTerminalPagingResponse>;
        }));
    }

    protected processQueryPosQRTerminal(response: HttpResponseBase): Observable<ListItemPosQRTerminalPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListItemPosQRTerminalPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemPosQRTerminalPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    updatePosQRTerminal(body?: UpdatePosQRTerminal | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PosQRTerminal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosQRTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosQRTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePosQRTerminal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPosQRTerminal(id: number): Observable<DetailsPosQRTerminal> {
        let url_ = this.baseUrl + "/api/PosQRTerminal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosQRTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosQRTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetailsPosQRTerminal>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetailsPosQRTerminal>;
        }));
    }

    protected processGetPosQRTerminal(response: HttpResponseBase): Observable<DetailsPosQRTerminal> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DetailsPosQRTerminal;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DetailsPosQRTerminal>(null as any);
    }

    /**
     * @return Success
     */
    getPosQRTerminalLogs(posQrTerminalId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/PosQRTerminal/{posQrTerminalId}/Logs";
        if (posQrTerminalId === undefined || posQrTerminalId === null)
            throw new Error("The parameter 'posQrTerminalId' must be defined.");
        url_ = url_.replace("{posQrTerminalId}", encodeURIComponent("" + posQrTerminalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosQRTerminalLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosQRTerminalLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetPosQRTerminalLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @return No Content
     */
    changePosQRTerminalStatus(id: number, status: PosQRTerminalStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/PosQRTerminal/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePosQRTerminalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePosQRTerminalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePosQRTerminalStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPosQRTerminalRegister(merchantExternalId: string, body?: RegisterPosQRTerminal | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/PosQRTerminal/PosQRMerchant/{merchantExternalId}/Register";
        if (merchantExternalId === undefined || merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' must be defined.");
        url_ = url_.replace("{merchantExternalId}", encodeURIComponent("" + merchantExternalId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPosQRTerminalRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPosQRTerminalRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddPosQRTerminalRegister(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return Success
     */
    isPosQRMerchantAccepted(merchantExternalId: string): Observable<IsMerchantAcceptedDto> {
        let url_ = this.baseUrl + "/api/PosQRTerminal/{merchantExternalId}/IsMerchantAccepted";
        if (merchantExternalId === undefined || merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' must be defined.");
        url_ = url_.replace("{merchantExternalId}", encodeURIComponent("" + merchantExternalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPosQRMerchantAccepted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPosQRMerchantAccepted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsMerchantAcceptedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsMerchantAcceptedDto>;
        }));
    }

    protected processIsPosQRMerchantAccepted(response: HttpResponseBase): Observable<IsMerchantAcceptedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IsMerchantAcceptedDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsMerchantAcceptedDto>(null as any);
    }
}

export interface IQRCodeClient {
    /**
     * @param searchModel_Code (optional) 
     * @param searchModel_GroupIdentifier (optional) 
     * @param searchModel_AdminUser (optional) 
     * @param searchModel_CreateDate_From (optional) 
     * @param searchModel_CreateDate_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    query(searchModel_Code?: string | undefined, searchModel_GroupIdentifier?: string | undefined, searchModel_AdminUser?: string | undefined, searchModel_CreateDate_From?: moment.Moment | undefined, searchModel_CreateDate_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<SearchQRCodesItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    generateGroup(body?: GenerateQRGroupRequestModel | undefined): Observable<GenerateQRGroupResponseModel>;
    printGroup(groupIdentifier: string, qrPrintType: QrPrintType): Observable<FileResponse>;
    print(qrCode: string, qrPrintType: QrPrintType): Observable<FileResponse>;
}

@Injectable()
export class QRCodeClient implements IQRCodeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_Code (optional) 
     * @param searchModel_GroupIdentifier (optional) 
     * @param searchModel_AdminUser (optional) 
     * @param searchModel_CreateDate_From (optional) 
     * @param searchModel_CreateDate_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    query(searchModel_Code?: string | undefined, searchModel_GroupIdentifier?: string | undefined, searchModel_AdminUser?: string | undefined, searchModel_CreateDate_From?: moment.Moment | undefined, searchModel_CreateDate_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<SearchQRCodesItemPagingResponse> {
        let url_ = this.baseUrl + "/api/QRCode?";
        if (searchModel_Code === null)
            throw new Error("The parameter 'searchModel_Code' cannot be null.");
        else if (searchModel_Code !== undefined)
            url_ += "SearchModel.Code=" + encodeURIComponent("" + searchModel_Code) + "&";
        if (searchModel_GroupIdentifier === null)
            throw new Error("The parameter 'searchModel_GroupIdentifier' cannot be null.");
        else if (searchModel_GroupIdentifier !== undefined)
            url_ += "SearchModel.GroupIdentifier=" + encodeURIComponent("" + searchModel_GroupIdentifier) + "&";
        if (searchModel_AdminUser === null)
            throw new Error("The parameter 'searchModel_AdminUser' cannot be null.");
        else if (searchModel_AdminUser !== undefined)
            url_ += "SearchModel.AdminUser=" + encodeURIComponent("" + searchModel_AdminUser) + "&";
        if (searchModel_CreateDate_From === null)
            throw new Error("The parameter 'searchModel_CreateDate_From' cannot be null.");
        else if (searchModel_CreateDate_From !== undefined)
            url_ += "SearchModel.CreateDate.From=" + encodeURIComponent(searchModel_CreateDate_From ? "" + searchModel_CreateDate_From.toISOString() : "") + "&";
        if (searchModel_CreateDate_To === null)
            throw new Error("The parameter 'searchModel_CreateDate_To' cannot be null.");
        else if (searchModel_CreateDate_To !== undefined)
            url_ += "SearchModel.CreateDate.To=" + encodeURIComponent(searchModel_CreateDate_To ? "" + searchModel_CreateDate_To.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchQRCodesItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchQRCodesItemPagingResponse>;
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<SearchQRCodesItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchQRCodesItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchQRCodesItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateGroup(body?: GenerateQRGroupRequestModel | undefined): Observable<GenerateQRGroupResponseModel> {
        let url_ = this.baseUrl + "/api/QRCode/QRGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateQRGroupResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateQRGroupResponseModel>;
        }));
    }

    protected processGenerateGroup(response: HttpResponseBase): Observable<GenerateQRGroupResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerateQRGroupResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenerateQRGroupResponseModel>(null as any);
    }

    printGroup(groupIdentifier: string, qrPrintType: QrPrintType): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/QRCode/QRGroup/{groupIdentifier}/print/{qrPrintType}";
        if (groupIdentifier === undefined || groupIdentifier === null)
            throw new Error("The parameter 'groupIdentifier' must be defined.");
        url_ = url_.replace("{groupIdentifier}", encodeURIComponent("" + groupIdentifier));
        if (qrPrintType === undefined || qrPrintType === null)
            throw new Error("The parameter 'qrPrintType' must be defined.");
        url_ = url_.replace("{qrPrintType}", encodeURIComponent("" + qrPrintType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/zip"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPrintGroup(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    print(qrCode: string, qrPrintType: QrPrintType): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/QRCode/{qrCode}/print/{qrPrintType}";
        if (qrCode === undefined || qrCode === null)
            throw new Error("The parameter 'qrCode' must be defined.");
        url_ = url_.replace("{qrCode}", encodeURIComponent("" + qrCode));
        if (qrPrintType === undefined || qrPrintType === null)
            throw new Error("The parameter 'qrPrintType' must be defined.");
        url_ = url_.replace("{qrPrintType}", encodeURIComponent("" + qrPrintType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPrint(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IQRMerchantsClient {
    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeNameEn (optional) 
     * @param searchModel_TradeNameKa (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryQRMerchants(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeNameEn?: string | undefined, searchModel_TradeNameKa?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<QRMerchantListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveQRMerchant(body?: UpdateQRMerchant | undefined): Observable<void>;
    /**
     * @return Success
     */
    getQRMerchant(id: number): Observable<QRMerchantDetails>;
    /**
     * @return Success
     */
    getQRMerchantLogs(qrMerchantId: number): Observable<ActionLogListItem[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addQrMerchantToCompany(companyId: number, body?: RegisterQRMerchantRequest | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    changeQrMerchantStatus(id: number, status: ServiceStatus): Observable<void>;
}

@Injectable()
export class QRMerchantsClient implements IQRMerchantsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeNameEn (optional) 
     * @param searchModel_TradeNameKa (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryQRMerchants(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeNameEn?: string | undefined, searchModel_TradeNameKa?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<QRMerchantListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/QRMerchants?";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeNameEn === null)
            throw new Error("The parameter 'searchModel_TradeNameEn' cannot be null.");
        else if (searchModel_TradeNameEn !== undefined)
            url_ += "SearchModel.TradeNameEn=" + encodeURIComponent("" + searchModel_TradeNameEn) + "&";
        if (searchModel_TradeNameKa === null)
            throw new Error("The parameter 'searchModel_TradeNameKa' cannot be null.");
        else if (searchModel_TradeNameKa !== undefined)
            url_ += "SearchModel.TradeNameKa=" + encodeURIComponent("" + searchModel_TradeNameKa) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryQRMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryQRMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRMerchantListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRMerchantListItemPagingResponse>;
        }));
    }

    protected processQueryQRMerchants(response: HttpResponseBase): Observable<QRMerchantListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as QRMerchantListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRMerchantListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveQRMerchant(body?: UpdateQRMerchant | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/QRMerchants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQRMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQRMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveQRMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getQRMerchant(id: number): Observable<QRMerchantDetails> {
        let url_ = this.baseUrl + "/api/QRMerchants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRMerchantDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRMerchantDetails>;
        }));
    }

    protected processGetQRMerchant(response: HttpResponseBase): Observable<QRMerchantDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as QRMerchantDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRMerchantDetails>(null as any);
    }

    /**
     * @return Success
     */
    getQRMerchantLogs(qrMerchantId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/QRMerchants/{qrMerchantId}/Logs";
        if (qrMerchantId === undefined || qrMerchantId === null)
            throw new Error("The parameter 'qrMerchantId' must be defined.");
        url_ = url_.replace("{qrMerchantId}", encodeURIComponent("" + qrMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRMerchantLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRMerchantLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetQRMerchantLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addQrMerchantToCompany(companyId: number, body?: RegisterQRMerchantRequest | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRMerchants/Company/{companyId}/QRMerchantRegister";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddQrMerchantToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddQrMerchantToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddQrMerchantToCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    changeQrMerchantStatus(id: number, status: ServiceStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/QRMerchants/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeQrMerchantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeQrMerchantStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeQrMerchantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IQRPaymentClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    addCashierToCashDesk(cashDeskId: number, body?: AddCashierToCashDesk | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    deleteCashierFromCashDesk(cashDeskCashierId: number): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDesk(qrPaymentId: number, body?: AddCashDesk | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    editCashDeskName(cashDeskId: number, cashDeskName: string): Observable<void>;
    /**
     * @return No Content
     */
    deleteCashDesk(cashDeskId: number): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDeskWithExistingQr(qrPaymentId: number, body?: AddCashDeskWithExistingQr | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    generateQrCodeForCashDesk(cashDeskId: number): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDeskWithDevice(qrPaymentId: number, body?: AddCashDeskWithDevice | undefined): Observable<IdResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    addDeviceToCashDesk(cashDeskId: number, body?: AddDeviceToCashDesk | undefined): Observable<void>;
    /**
     * @return No Content
     */
    deleteDeviceFromCashDesk(cashDeskDeviceId: number): Observable<void>;
    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeNameEn (optional) 
     * @param searchModel_TradeNameKa (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryQRPayments(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeNameEn?: string | undefined, searchModel_TradeNameKa?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<QRPaymentListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveQRPayment(body?: UpdateQRPayment | undefined): Observable<void>;
    /**
     * @return Success
     */
    getQRPayment(id: number): Observable<QRPaymentDetails>;
    /**
     * @return Success
     */
    getQRPaymentLogs(qrPaymentId: number): Observable<ActionLogListItem[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addQRPaymentToCompany(companyId: number, body?: RegisterQRPaymentRequest | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    changeQRPaymentStatus(qrPaymentId: number, status: ServiceStatus): Observable<void>;
    /**
     * @return Success
     */
    findQrPaymentByQRCode(qRCode: string): Observable<IdResponse>;
}

@Injectable()
export class QRPaymentClient implements IQRPaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCashierToCashDesk(cashDeskId: number, body?: AddCashierToCashDesk | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/{cashDeskId}/Cashier";
        if (cashDeskId === undefined || cashDeskId === null)
            throw new Error("The parameter 'cashDeskId' must be defined.");
        url_ = url_.replace("{cashDeskId}", encodeURIComponent("" + cashDeskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCashierToCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCashierToCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddCashierToCashDesk(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    deleteCashierFromCashDesk(cashDeskCashierId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/Cashier/{cashDeskCashierId}";
        if (cashDeskCashierId === undefined || cashDeskCashierId === null)
            throw new Error("The parameter 'cashDeskCashierId' must be defined.");
        url_ = url_.replace("{cashDeskCashierId}", encodeURIComponent("" + cashDeskCashierId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCashierFromCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCashierFromCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCashierFromCashDesk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDesk(qrPaymentId: number, body?: AddCashDesk | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/{qrPaymentId}/CashDesk";
        if (qrPaymentId === undefined || qrPaymentId === null)
            throw new Error("The parameter 'qrPaymentId' must be defined.");
        url_ = url_.replace("{qrPaymentId}", encodeURIComponent("" + qrPaymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddCashDesk(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    editCashDeskName(cashDeskId: number, cashDeskName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/{cashDeskId}/Name/{cashDeskName}";
        if (cashDeskId === undefined || cashDeskId === null)
            throw new Error("The parameter 'cashDeskId' must be defined.");
        url_ = url_.replace("{cashDeskId}", encodeURIComponent("" + cashDeskId));
        if (cashDeskName === undefined || cashDeskName === null)
            throw new Error("The parameter 'cashDeskName' must be defined.");
        url_ = url_.replace("{cashDeskName}", encodeURIComponent("" + cashDeskName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCashDeskName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCashDeskName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditCashDeskName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return No Content
     */
    deleteCashDesk(cashDeskId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/{cashDeskId}";
        if (cashDeskId === undefined || cashDeskId === null)
            throw new Error("The parameter 'cashDeskId' must be defined.");
        url_ = url_.replace("{cashDeskId}", encodeURIComponent("" + cashDeskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCashDesk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDeskWithExistingQr(qrPaymentId: number, body?: AddCashDeskWithExistingQr | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/{qrPaymentId}/CashDeskWithQrCode";
        if (qrPaymentId === undefined || qrPaymentId === null)
            throw new Error("The parameter 'qrPaymentId' must be defined.");
        url_ = url_.replace("{qrPaymentId}", encodeURIComponent("" + qrPaymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCashDeskWithExistingQr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCashDeskWithExistingQr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddCashDeskWithExistingQr(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    generateQrCodeForCashDesk(cashDeskId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/{cashDeskId}/QRCode/Generate";
        if (cashDeskId === undefined || cashDeskId === null)
            throw new Error("The parameter 'cashDeskId' must be defined.");
        url_ = url_.replace("{cashDeskId}", encodeURIComponent("" + cashDeskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateQrCodeForCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateQrCodeForCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateQrCodeForCashDesk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCashDeskWithDevice(qrPaymentId: number, body?: AddCashDeskWithDevice | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/{qrPaymentId}/CashDeskWithDevice";
        if (qrPaymentId === undefined || qrPaymentId === null)
            throw new Error("The parameter 'qrPaymentId' must be defined.");
        url_ = url_.replace("{qrPaymentId}", encodeURIComponent("" + qrPaymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCashDeskWithDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCashDeskWithDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddCashDeskWithDevice(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    addDeviceToCashDesk(cashDeskId: number, body?: AddDeviceToCashDesk | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/{cashDeskId}/Device";
        if (cashDeskId === undefined || cashDeskId === null)
            throw new Error("The parameter 'cashDeskId' must be defined.");
        url_ = url_.replace("{cashDeskId}", encodeURIComponent("" + cashDeskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeviceToCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeviceToCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddDeviceToCashDesk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return No Content
     */
    deleteDeviceFromCashDesk(cashDeskDeviceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/CashDesk/Device/{cashDeskDeviceId}";
        if (cashDeskDeviceId === undefined || cashDeskDeviceId === null)
            throw new Error("The parameter 'cashDeskDeviceId' must be defined.");
        url_ = url_.replace("{cashDeskDeviceId}", encodeURIComponent("" + cashDeskDeviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceFromCashDesk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceFromCashDesk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDeviceFromCashDesk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeNameEn (optional) 
     * @param searchModel_TradeNameKa (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryQRPayments(searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeNameEn?: string | undefined, searchModel_TradeNameKa?: string | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<QRPaymentListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/QRPayment?";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeNameEn === null)
            throw new Error("The parameter 'searchModel_TradeNameEn' cannot be null.");
        else if (searchModel_TradeNameEn !== undefined)
            url_ += "SearchModel.TradeNameEn=" + encodeURIComponent("" + searchModel_TradeNameEn) + "&";
        if (searchModel_TradeNameKa === null)
            throw new Error("The parameter 'searchModel_TradeNameKa' cannot be null.");
        else if (searchModel_TradeNameKa !== undefined)
            url_ += "SearchModel.TradeNameKa=" + encodeURIComponent("" + searchModel_TradeNameKa) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryQRPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryQRPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRPaymentListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRPaymentListItemPagingResponse>;
        }));
    }

    protected processQueryQRPayments(response: HttpResponseBase): Observable<QRPaymentListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as QRPaymentListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRPaymentListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveQRPayment(body?: UpdateQRPayment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQRPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQRPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveQRPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getQRPayment(id: number): Observable<QRPaymentDetails> {
        let url_ = this.baseUrl + "/api/QRPayment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRPaymentDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRPaymentDetails>;
        }));
    }

    protected processGetQRPayment(response: HttpResponseBase): Observable<QRPaymentDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as QRPaymentDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRPaymentDetails>(null as any);
    }

    /**
     * @return Success
     */
    getQRPaymentLogs(qrPaymentId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/QRPayment/{qrPaymentId}/Logs";
        if (qrPaymentId === undefined || qrPaymentId === null)
            throw new Error("The parameter 'qrPaymentId' must be defined.");
        url_ = url_.replace("{qrPaymentId}", encodeURIComponent("" + qrPaymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQRPaymentLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQRPaymentLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetQRPaymentLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addQRPaymentToCompany(companyId: number, body?: RegisterQRPaymentRequest | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/Company/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddQRPaymentToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddQRPaymentToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddQRPaymentToCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    changeQRPaymentStatus(qrPaymentId: number, status: ServiceStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/QRPayment/{qrPaymentId}/Status/{status}";
        if (qrPaymentId === undefined || qrPaymentId === null)
            throw new Error("The parameter 'qrPaymentId' must be defined.");
        url_ = url_.replace("{qrPaymentId}", encodeURIComponent("" + qrPaymentId));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeQRPaymentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeQRPaymentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeQRPaymentStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    findQrPaymentByQRCode(qRCode: string): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/QRPayment/FindByQRCode/{qRCode}";
        if (qRCode === undefined || qRCode === null)
            throw new Error("The parameter 'qRCode' must be defined.");
        url_ = url_.replace("{qRCode}", encodeURIComponent("" + qRCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindQrPaymentByQRCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindQrPaymentByQRCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processFindQrPaymentByQRCode(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }
}

export interface IRecurringCardClient {
    /**
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_PaymentGenId (optional) 
     * @param searchModel_MerchantPaymentId (optional) 
     * @param searchModel_CardMask (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_CardType (optional) 
     * @param searchModel_RecurringType (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_ExpiryDate_From (optional) 
     * @param searchModel_ExpiryDate_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryRecurringCards(searchModel_MerchantExternalId?: string | undefined, searchModel_MerchantTradeName?: string | undefined, searchModel_PaymentGenId?: string | undefined, searchModel_MerchantPaymentId?: string | undefined, searchModel_CardMask?: string | undefined, searchModel_Status?: RecurringCardStatus | undefined, searchModel_CardType?: RecurringCardType | undefined, searchModel_RecurringType?: RecurringType | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_ExpiryDate_From?: moment.Moment | undefined, searchModel_ExpiryDate_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<RecurringCardsListItemPagingResponse>;
    /**
     * @return Success
     */
    getRecurringCard(id: number): Observable<RecurringCardDetailsModel>;
    exportRecurringCards(merchantExternalId?: string | undefined, merchantTradeName?: string | undefined, paymentGenId?: string | undefined, merchantPaymentId?: string | undefined, cardMask?: string | undefined, status?: RecurringCardStatus | undefined, cardType?: RecurringCardType | undefined, recurringType?: RecurringType | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, expiryDate_From?: moment.Moment | undefined, expiryDate_To?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class RecurringCardClient implements IRecurringCardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_MerchantTradeName (optional) 
     * @param searchModel_PaymentGenId (optional) 
     * @param searchModel_MerchantPaymentId (optional) 
     * @param searchModel_CardMask (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_CardType (optional) 
     * @param searchModel_RecurringType (optional) 
     * @param searchModel_DateCreated_From (optional) 
     * @param searchModel_DateCreated_To (optional) 
     * @param searchModel_ExpiryDate_From (optional) 
     * @param searchModel_ExpiryDate_To (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryRecurringCards(searchModel_MerchantExternalId?: string | undefined, searchModel_MerchantTradeName?: string | undefined, searchModel_PaymentGenId?: string | undefined, searchModel_MerchantPaymentId?: string | undefined, searchModel_CardMask?: string | undefined, searchModel_Status?: RecurringCardStatus | undefined, searchModel_CardType?: RecurringCardType | undefined, searchModel_RecurringType?: RecurringType | undefined, searchModel_DateCreated_From?: moment.Moment | undefined, searchModel_DateCreated_To?: moment.Moment | undefined, searchModel_ExpiryDate_From?: moment.Moment | undefined, searchModel_ExpiryDate_To?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<RecurringCardsListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/RecurringCard?";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_MerchantTradeName === null)
            throw new Error("The parameter 'searchModel_MerchantTradeName' cannot be null.");
        else if (searchModel_MerchantTradeName !== undefined)
            url_ += "SearchModel.MerchantTradeName=" + encodeURIComponent("" + searchModel_MerchantTradeName) + "&";
        if (searchModel_PaymentGenId === null)
            throw new Error("The parameter 'searchModel_PaymentGenId' cannot be null.");
        else if (searchModel_PaymentGenId !== undefined)
            url_ += "SearchModel.PaymentGenId=" + encodeURIComponent("" + searchModel_PaymentGenId) + "&";
        if (searchModel_MerchantPaymentId === null)
            throw new Error("The parameter 'searchModel_MerchantPaymentId' cannot be null.");
        else if (searchModel_MerchantPaymentId !== undefined)
            url_ += "SearchModel.MerchantPaymentId=" + encodeURIComponent("" + searchModel_MerchantPaymentId) + "&";
        if (searchModel_CardMask === null)
            throw new Error("The parameter 'searchModel_CardMask' cannot be null.");
        else if (searchModel_CardMask !== undefined)
            url_ += "SearchModel.CardMask=" + encodeURIComponent("" + searchModel_CardMask) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_CardType === null)
            throw new Error("The parameter 'searchModel_CardType' cannot be null.");
        else if (searchModel_CardType !== undefined)
            url_ += "SearchModel.CardType=" + encodeURIComponent("" + searchModel_CardType) + "&";
        if (searchModel_RecurringType === null)
            throw new Error("The parameter 'searchModel_RecurringType' cannot be null.");
        else if (searchModel_RecurringType !== undefined)
            url_ += "SearchModel.RecurringType=" + encodeURIComponent("" + searchModel_RecurringType) + "&";
        if (searchModel_DateCreated_From === null)
            throw new Error("The parameter 'searchModel_DateCreated_From' cannot be null.");
        else if (searchModel_DateCreated_From !== undefined)
            url_ += "SearchModel.DateCreated.From=" + encodeURIComponent(searchModel_DateCreated_From ? "" + searchModel_DateCreated_From.toISOString() : "") + "&";
        if (searchModel_DateCreated_To === null)
            throw new Error("The parameter 'searchModel_DateCreated_To' cannot be null.");
        else if (searchModel_DateCreated_To !== undefined)
            url_ += "SearchModel.DateCreated.To=" + encodeURIComponent(searchModel_DateCreated_To ? "" + searchModel_DateCreated_To.toISOString() : "") + "&";
        if (searchModel_ExpiryDate_From === null)
            throw new Error("The parameter 'searchModel_ExpiryDate_From' cannot be null.");
        else if (searchModel_ExpiryDate_From !== undefined)
            url_ += "SearchModel.ExpiryDate.From=" + encodeURIComponent(searchModel_ExpiryDate_From ? "" + searchModel_ExpiryDate_From.toISOString() : "") + "&";
        if (searchModel_ExpiryDate_To === null)
            throw new Error("The parameter 'searchModel_ExpiryDate_To' cannot be null.");
        else if (searchModel_ExpiryDate_To !== undefined)
            url_ += "SearchModel.ExpiryDate.To=" + encodeURIComponent(searchModel_ExpiryDate_To ? "" + searchModel_ExpiryDate_To.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryRecurringCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryRecurringCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecurringCardsListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecurringCardsListItemPagingResponse>;
        }));
    }

    protected processQueryRecurringCards(response: HttpResponseBase): Observable<RecurringCardsListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RecurringCardsListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringCardsListItemPagingResponse>(null as any);
    }

    /**
     * @return Success
     */
    getRecurringCard(id: number): Observable<RecurringCardDetailsModel> {
        let url_ = this.baseUrl + "/api/RecurringCard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurringCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurringCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecurringCardDetailsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecurringCardDetailsModel>;
        }));
    }

    protected processGetRecurringCard(response: HttpResponseBase): Observable<RecurringCardDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RecurringCardDetailsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringCardDetailsModel>(null as any);
    }

    exportRecurringCards(merchantExternalId?: string | undefined, merchantTradeName?: string | undefined, paymentGenId?: string | undefined, merchantPaymentId?: string | undefined, cardMask?: string | undefined, status?: RecurringCardStatus | undefined, cardType?: RecurringCardType | undefined, recurringType?: RecurringType | undefined, dateCreated_From?: moment.Moment | undefined, dateCreated_To?: moment.Moment | undefined, expiryDate_From?: moment.Moment | undefined, expiryDate_To?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RecurringCard/Export?";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (merchantTradeName === null)
            throw new Error("The parameter 'merchantTradeName' cannot be null.");
        else if (merchantTradeName !== undefined)
            url_ += "MerchantTradeName=" + encodeURIComponent("" + merchantTradeName) + "&";
        if (paymentGenId === null)
            throw new Error("The parameter 'paymentGenId' cannot be null.");
        else if (paymentGenId !== undefined)
            url_ += "PaymentGenId=" + encodeURIComponent("" + paymentGenId) + "&";
        if (merchantPaymentId === null)
            throw new Error("The parameter 'merchantPaymentId' cannot be null.");
        else if (merchantPaymentId !== undefined)
            url_ += "MerchantPaymentId=" + encodeURIComponent("" + merchantPaymentId) + "&";
        if (cardMask === null)
            throw new Error("The parameter 'cardMask' cannot be null.");
        else if (cardMask !== undefined)
            url_ += "CardMask=" + encodeURIComponent("" + cardMask) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (cardType === null)
            throw new Error("The parameter 'cardType' cannot be null.");
        else if (cardType !== undefined)
            url_ += "CardType=" + encodeURIComponent("" + cardType) + "&";
        if (recurringType === null)
            throw new Error("The parameter 'recurringType' cannot be null.");
        else if (recurringType !== undefined)
            url_ += "RecurringType=" + encodeURIComponent("" + recurringType) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent(dateCreated_From ? "" + dateCreated_From.toISOString() : "") + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent(dateCreated_To ? "" + dateCreated_To.toISOString() : "") + "&";
        if (expiryDate_From === null)
            throw new Error("The parameter 'expiryDate_From' cannot be null.");
        else if (expiryDate_From !== undefined)
            url_ += "ExpiryDate.From=" + encodeURIComponent(expiryDate_From ? "" + expiryDate_From.toISOString() : "") + "&";
        if (expiryDate_To === null)
            throw new Error("The parameter 'expiryDate_To' cannot be null.");
        else if (expiryDate_To !== undefined)
            url_ += "ExpiryDate.To=" + encodeURIComponent(expiryDate_To ? "" + expiryDate_To.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportRecurringCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportRecurringCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportRecurringCards(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface ITransactionClient {
    /**
     * @param searchModel_TransactionId (optional) 
     * @param searchModel_CustomerIp (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_ConfirmedAmount (optional) 
     * @param searchModel_ReturnedAmount (optional) 
     * @param searchModel_Description (optional) 
     * @param searchModel_PaymentMerchantId (optional) 
     * @param searchModel_PaymentMerchantName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Rrn (optional) 
     * @param searchModel_CreateDate_From (optional) 
     * @param searchModel_CreateDate_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_UserInfo (optional) 
     * @param searchModel_IsBnpl (optional) 
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_PhysicalTerminalNo (optional) 
     * @param searchModel_Initiator (optional) 
     * @param searchModel_ResponseCode (optional) 
     * @param searchModel_PaymentGenId (optional) 
     * @param searchModel_ParentPaymentGenId (optional) 
     * @param searchModel_PaymentChannel (optional) 
     * @param searchModel_PaymentMethod (optional) 
     * @param searchModel_TransactionType (optional) 
     * @param searchModel_QRCode (optional) 
     * @param searchModel_OperatorContact (optional) 
     * @param searchModel_HadCancellationProblem (optional) 
     * @param searchModel_MerchantPaymentId (optional) 
     * @param searchModel_PaymentType (optional) 
     * @param searchModel_PaymentObjectType (optional) 
     * @param searchModel_InitializerType (optional) 
     * @param searchModel_PayByLinkProductId (optional) 
     * @param searchModel_PayByLinkBasketId (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryTransactions(searchModel_TransactionId?: string | undefined, searchModel_CustomerIp?: string | undefined, searchModel_Amount?: number | undefined, searchModel_Currency?: Currency | undefined, searchModel_ConfirmedAmount?: number | undefined, searchModel_ReturnedAmount?: number | undefined, searchModel_Description?: string | undefined, searchModel_PaymentMerchantId?: string | undefined, searchModel_PaymentMerchantName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Rrn?: string | undefined, searchModel_CreateDate_From?: moment.Moment | undefined, searchModel_CreateDate_To?: moment.Moment | undefined, searchModel_Status?: PaymentStatus | undefined, searchModel_UserInfo?: string | undefined, searchModel_IsBnpl?: boolean | undefined, searchModel_TerminalNo?: string | undefined, searchModel_PhysicalTerminalNo?: string | undefined, searchModel_Initiator?: RecurringPaymentType | undefined, searchModel_ResponseCode?: string | undefined, searchModel_PaymentGenId?: string | undefined, searchModel_ParentPaymentGenId?: string | undefined, searchModel_PaymentChannel?: PaymentChannel | undefined, searchModel_PaymentMethod?: PayMethod | undefined, searchModel_TransactionType?: TransactionType | undefined, searchModel_QRCode?: string | undefined, searchModel_OperatorContact?: string | undefined, searchModel_HadCancellationProblem?: boolean | undefined, searchModel_MerchantPaymentId?: string | undefined, searchModel_PaymentType?: PaymentType | undefined, searchModel_PaymentObjectType?: PaymentObjectType | undefined, searchModel_InitializerType?: InitializerType | undefined, searchModel_PayByLinkProductId?: number | undefined, searchModel_PayByLinkBasketId?: number | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<SearchTransactionsResponse>;
    /**
     * @return Success
     */
    getTransaction(id: number): Observable<TransactionDetailsModel>;
    /**
     * @return Success
     */
    getPaymentMethods(): Observable<DropDownListItemModel[]>;
    /**
     * @return Success
     */
    getCurrencies(): Observable<DropDownListItemModel[]>;
    /**
     * @param amount (optional) 
     * @return Success
     */
    reverseTransaction(id: number, amount?: number | undefined): Observable<void>;
    /**
     * @param amount (optional) 
     * @return Success
     */
    refundTransaction(id: number, amount?: number | undefined): Observable<void>;
    /**
     * @return Success
     */
    checkRefundLimits(id: number): Observable<ApiResponse>;
    exportTransactions(transactionId?: string | undefined, customerIp?: string | undefined, amount?: number | undefined, currency?: Currency | undefined, confirmedAmount?: number | undefined, returnedAmount?: number | undefined, description?: string | undefined, paymentMerchantId?: string | undefined, paymentMerchantName?: string | undefined, companyIdentificationNumber?: string | undefined, rrn?: string | undefined, createDate_From?: moment.Moment | undefined, createDate_To?: moment.Moment | undefined, status?: PaymentStatus | undefined, userInfo?: string | undefined, isBnpl?: boolean | undefined, terminalNo?: string | undefined, physicalTerminalNo?: string | undefined, initiator?: RecurringPaymentType | undefined, responseCode?: string | undefined, paymentGenId?: string | undefined, parentPaymentGenId?: string | undefined, paymentChannel?: PaymentChannel | undefined, paymentMethod?: PayMethod | undefined, transactionType?: TransactionType | undefined, qRCode?: string | undefined, operatorContact?: string | undefined, hadCancellationProblem?: boolean | undefined, merchantPaymentId?: string | undefined, paymentType?: PaymentType | undefined, paymentObjectType?: PaymentObjectType | undefined, initializerType?: InitializerType | undefined, payByLinkProductId?: number | undefined, payByLinkBasketId?: number | undefined): Observable<FileResponse>;
    /**
     * @return Success
     */
    getTransactionLogs(id: number): Observable<ActionLogListItem[]>;
    /**
     * @return Success
     */
    getTransactionApiLogs(id: number): Observable<ApiLogListItem[]>;
    /**
     * @param searchModel_Id (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getTransactionPaymentLogs(id: string, searchModel_Id?: number | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<TransactionPaymentLogResponse>;
    /**
     * @param isSuccessful (optional) 
     * @return Success
     */
    trasnactionChangeStatus(paymentId: number, isSuccessful?: boolean | undefined): Observable<void>;
}

@Injectable()
export class TransactionClient implements ITransactionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_TransactionId (optional) 
     * @param searchModel_CustomerIp (optional) 
     * @param searchModel_Amount (optional) 
     * @param searchModel_Currency (optional) 
     * @param searchModel_ConfirmedAmount (optional) 
     * @param searchModel_ReturnedAmount (optional) 
     * @param searchModel_Description (optional) 
     * @param searchModel_PaymentMerchantId (optional) 
     * @param searchModel_PaymentMerchantName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Rrn (optional) 
     * @param searchModel_CreateDate_From (optional) 
     * @param searchModel_CreateDate_To (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_UserInfo (optional) 
     * @param searchModel_IsBnpl (optional) 
     * @param searchModel_TerminalNo (optional) 
     * @param searchModel_PhysicalTerminalNo (optional) 
     * @param searchModel_Initiator (optional) 
     * @param searchModel_ResponseCode (optional) 
     * @param searchModel_PaymentGenId (optional) 
     * @param searchModel_ParentPaymentGenId (optional) 
     * @param searchModel_PaymentChannel (optional) 
     * @param searchModel_PaymentMethod (optional) 
     * @param searchModel_TransactionType (optional) 
     * @param searchModel_QRCode (optional) 
     * @param searchModel_OperatorContact (optional) 
     * @param searchModel_HadCancellationProblem (optional) 
     * @param searchModel_MerchantPaymentId (optional) 
     * @param searchModel_PaymentType (optional) 
     * @param searchModel_PaymentObjectType (optional) 
     * @param searchModel_InitializerType (optional) 
     * @param searchModel_PayByLinkProductId (optional) 
     * @param searchModel_PayByLinkBasketId (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryTransactions(searchModel_TransactionId?: string | undefined, searchModel_CustomerIp?: string | undefined, searchModel_Amount?: number | undefined, searchModel_Currency?: Currency | undefined, searchModel_ConfirmedAmount?: number | undefined, searchModel_ReturnedAmount?: number | undefined, searchModel_Description?: string | undefined, searchModel_PaymentMerchantId?: string | undefined, searchModel_PaymentMerchantName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Rrn?: string | undefined, searchModel_CreateDate_From?: moment.Moment | undefined, searchModel_CreateDate_To?: moment.Moment | undefined, searchModel_Status?: PaymentStatus | undefined, searchModel_UserInfo?: string | undefined, searchModel_IsBnpl?: boolean | undefined, searchModel_TerminalNo?: string | undefined, searchModel_PhysicalTerminalNo?: string | undefined, searchModel_Initiator?: RecurringPaymentType | undefined, searchModel_ResponseCode?: string | undefined, searchModel_PaymentGenId?: string | undefined, searchModel_ParentPaymentGenId?: string | undefined, searchModel_PaymentChannel?: PaymentChannel | undefined, searchModel_PaymentMethod?: PayMethod | undefined, searchModel_TransactionType?: TransactionType | undefined, searchModel_QRCode?: string | undefined, searchModel_OperatorContact?: string | undefined, searchModel_HadCancellationProblem?: boolean | undefined, searchModel_MerchantPaymentId?: string | undefined, searchModel_PaymentType?: PaymentType | undefined, searchModel_PaymentObjectType?: PaymentObjectType | undefined, searchModel_InitializerType?: InitializerType | undefined, searchModel_PayByLinkProductId?: number | undefined, searchModel_PayByLinkBasketId?: number | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<SearchTransactionsResponse> {
        let url_ = this.baseUrl + "/api/Transaction?";
        if (searchModel_TransactionId === null)
            throw new Error("The parameter 'searchModel_TransactionId' cannot be null.");
        else if (searchModel_TransactionId !== undefined)
            url_ += "SearchModel.TransactionId=" + encodeURIComponent("" + searchModel_TransactionId) + "&";
        if (searchModel_CustomerIp === null)
            throw new Error("The parameter 'searchModel_CustomerIp' cannot be null.");
        else if (searchModel_CustomerIp !== undefined)
            url_ += "SearchModel.CustomerIp=" + encodeURIComponent("" + searchModel_CustomerIp) + "&";
        if (searchModel_Amount === null)
            throw new Error("The parameter 'searchModel_Amount' cannot be null.");
        else if (searchModel_Amount !== undefined)
            url_ += "SearchModel.Amount=" + encodeURIComponent("" + searchModel_Amount) + "&";
        if (searchModel_Currency === null)
            throw new Error("The parameter 'searchModel_Currency' cannot be null.");
        else if (searchModel_Currency !== undefined)
            url_ += "SearchModel.Currency=" + encodeURIComponent("" + searchModel_Currency) + "&";
        if (searchModel_ConfirmedAmount === null)
            throw new Error("The parameter 'searchModel_ConfirmedAmount' cannot be null.");
        else if (searchModel_ConfirmedAmount !== undefined)
            url_ += "SearchModel.ConfirmedAmount=" + encodeURIComponent("" + searchModel_ConfirmedAmount) + "&";
        if (searchModel_ReturnedAmount === null)
            throw new Error("The parameter 'searchModel_ReturnedAmount' cannot be null.");
        else if (searchModel_ReturnedAmount !== undefined)
            url_ += "SearchModel.ReturnedAmount=" + encodeURIComponent("" + searchModel_ReturnedAmount) + "&";
        if (searchModel_Description === null)
            throw new Error("The parameter 'searchModel_Description' cannot be null.");
        else if (searchModel_Description !== undefined)
            url_ += "SearchModel.Description=" + encodeURIComponent("" + searchModel_Description) + "&";
        if (searchModel_PaymentMerchantId === null)
            throw new Error("The parameter 'searchModel_PaymentMerchantId' cannot be null.");
        else if (searchModel_PaymentMerchantId !== undefined)
            url_ += "SearchModel.PaymentMerchantId=" + encodeURIComponent("" + searchModel_PaymentMerchantId) + "&";
        if (searchModel_PaymentMerchantName === null)
            throw new Error("The parameter 'searchModel_PaymentMerchantName' cannot be null.");
        else if (searchModel_PaymentMerchantName !== undefined)
            url_ += "SearchModel.PaymentMerchantName=" + encodeURIComponent("" + searchModel_PaymentMerchantName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_Rrn === null)
            throw new Error("The parameter 'searchModel_Rrn' cannot be null.");
        else if (searchModel_Rrn !== undefined)
            url_ += "SearchModel.Rrn=" + encodeURIComponent("" + searchModel_Rrn) + "&";
        if (searchModel_CreateDate_From === null)
            throw new Error("The parameter 'searchModel_CreateDate_From' cannot be null.");
        else if (searchModel_CreateDate_From !== undefined)
            url_ += "SearchModel.CreateDate.From=" + encodeURIComponent(searchModel_CreateDate_From ? "" + searchModel_CreateDate_From.toISOString() : "") + "&";
        if (searchModel_CreateDate_To === null)
            throw new Error("The parameter 'searchModel_CreateDate_To' cannot be null.");
        else if (searchModel_CreateDate_To !== undefined)
            url_ += "SearchModel.CreateDate.To=" + encodeURIComponent(searchModel_CreateDate_To ? "" + searchModel_CreateDate_To.toISOString() : "") + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_UserInfo === null)
            throw new Error("The parameter 'searchModel_UserInfo' cannot be null.");
        else if (searchModel_UserInfo !== undefined)
            url_ += "SearchModel.UserInfo=" + encodeURIComponent("" + searchModel_UserInfo) + "&";
        if (searchModel_IsBnpl === null)
            throw new Error("The parameter 'searchModel_IsBnpl' cannot be null.");
        else if (searchModel_IsBnpl !== undefined)
            url_ += "SearchModel.IsBnpl=" + encodeURIComponent("" + searchModel_IsBnpl) + "&";
        if (searchModel_TerminalNo === null)
            throw new Error("The parameter 'searchModel_TerminalNo' cannot be null.");
        else if (searchModel_TerminalNo !== undefined)
            url_ += "SearchModel.TerminalNo=" + encodeURIComponent("" + searchModel_TerminalNo) + "&";
        if (searchModel_PhysicalTerminalNo === null)
            throw new Error("The parameter 'searchModel_PhysicalTerminalNo' cannot be null.");
        else if (searchModel_PhysicalTerminalNo !== undefined)
            url_ += "SearchModel.PhysicalTerminalNo=" + encodeURIComponent("" + searchModel_PhysicalTerminalNo) + "&";
        if (searchModel_Initiator === null)
            throw new Error("The parameter 'searchModel_Initiator' cannot be null.");
        else if (searchModel_Initiator !== undefined)
            url_ += "SearchModel.Initiator=" + encodeURIComponent("" + searchModel_Initiator) + "&";
        if (searchModel_ResponseCode === null)
            throw new Error("The parameter 'searchModel_ResponseCode' cannot be null.");
        else if (searchModel_ResponseCode !== undefined)
            url_ += "SearchModel.ResponseCode=" + encodeURIComponent("" + searchModel_ResponseCode) + "&";
        if (searchModel_PaymentGenId === null)
            throw new Error("The parameter 'searchModel_PaymentGenId' cannot be null.");
        else if (searchModel_PaymentGenId !== undefined)
            url_ += "SearchModel.PaymentGenId=" + encodeURIComponent("" + searchModel_PaymentGenId) + "&";
        if (searchModel_ParentPaymentGenId === null)
            throw new Error("The parameter 'searchModel_ParentPaymentGenId' cannot be null.");
        else if (searchModel_ParentPaymentGenId !== undefined)
            url_ += "SearchModel.ParentPaymentGenId=" + encodeURIComponent("" + searchModel_ParentPaymentGenId) + "&";
        if (searchModel_PaymentChannel === null)
            throw new Error("The parameter 'searchModel_PaymentChannel' cannot be null.");
        else if (searchModel_PaymentChannel !== undefined)
            url_ += "SearchModel.PaymentChannel=" + encodeURIComponent("" + searchModel_PaymentChannel) + "&";
        if (searchModel_PaymentMethod === null)
            throw new Error("The parameter 'searchModel_PaymentMethod' cannot be null.");
        else if (searchModel_PaymentMethod !== undefined)
            url_ += "SearchModel.PaymentMethod=" + encodeURIComponent("" + searchModel_PaymentMethod) + "&";
        if (searchModel_TransactionType === null)
            throw new Error("The parameter 'searchModel_TransactionType' cannot be null.");
        else if (searchModel_TransactionType !== undefined)
            url_ += "SearchModel.TransactionType=" + encodeURIComponent("" + searchModel_TransactionType) + "&";
        if (searchModel_QRCode === null)
            throw new Error("The parameter 'searchModel_QRCode' cannot be null.");
        else if (searchModel_QRCode !== undefined)
            url_ += "SearchModel.QRCode=" + encodeURIComponent("" + searchModel_QRCode) + "&";
        if (searchModel_OperatorContact === null)
            throw new Error("The parameter 'searchModel_OperatorContact' cannot be null.");
        else if (searchModel_OperatorContact !== undefined)
            url_ += "SearchModel.OperatorContact=" + encodeURIComponent("" + searchModel_OperatorContact) + "&";
        if (searchModel_HadCancellationProblem === null)
            throw new Error("The parameter 'searchModel_HadCancellationProblem' cannot be null.");
        else if (searchModel_HadCancellationProblem !== undefined)
            url_ += "SearchModel.HadCancellationProblem=" + encodeURIComponent("" + searchModel_HadCancellationProblem) + "&";
        if (searchModel_MerchantPaymentId === null)
            throw new Error("The parameter 'searchModel_MerchantPaymentId' cannot be null.");
        else if (searchModel_MerchantPaymentId !== undefined)
            url_ += "SearchModel.MerchantPaymentId=" + encodeURIComponent("" + searchModel_MerchantPaymentId) + "&";
        if (searchModel_PaymentType === null)
            throw new Error("The parameter 'searchModel_PaymentType' cannot be null.");
        else if (searchModel_PaymentType !== undefined)
            url_ += "SearchModel.PaymentType=" + encodeURIComponent("" + searchModel_PaymentType) + "&";
        if (searchModel_PaymentObjectType === null)
            throw new Error("The parameter 'searchModel_PaymentObjectType' cannot be null.");
        else if (searchModel_PaymentObjectType !== undefined)
            url_ += "SearchModel.PaymentObjectType=" + encodeURIComponent("" + searchModel_PaymentObjectType) + "&";
        if (searchModel_InitializerType === null)
            throw new Error("The parameter 'searchModel_InitializerType' cannot be null.");
        else if (searchModel_InitializerType !== undefined)
            url_ += "SearchModel.InitializerType=" + encodeURIComponent("" + searchModel_InitializerType) + "&";
        if (searchModel_PayByLinkProductId === null)
            throw new Error("The parameter 'searchModel_PayByLinkProductId' cannot be null.");
        else if (searchModel_PayByLinkProductId !== undefined)
            url_ += "SearchModel.PayByLinkProductId=" + encodeURIComponent("" + searchModel_PayByLinkProductId) + "&";
        if (searchModel_PayByLinkBasketId === null)
            throw new Error("The parameter 'searchModel_PayByLinkBasketId' cannot be null.");
        else if (searchModel_PayByLinkBasketId !== undefined)
            url_ += "SearchModel.PayByLinkBasketId=" + encodeURIComponent("" + searchModel_PayByLinkBasketId) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchTransactionsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchTransactionsResponse>;
        }));
    }

    protected processQueryTransactions(response: HttpResponseBase): Observable<SearchTransactionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchTransactionsResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchTransactionsResponse>(null as any);
    }

    /**
     * @return Success
     */
    getTransaction(id: number): Observable<TransactionDetailsModel> {
        let url_ = this.baseUrl + "/api/Transaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionDetailsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionDetailsModel>;
        }));
    }

    protected processGetTransaction(response: HttpResponseBase): Observable<TransactionDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionDetailsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionDetailsModel>(null as any);
    }

    /**
     * @return Success
     */
    getPaymentMethods(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/Transaction/PaymentMethods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetPaymentMethods(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getCurrencies(): Observable<DropDownListItemModel[]> {
        let url_ = this.baseUrl + "/api/Transaction/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DropDownListItemModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DropDownListItemModel[]>;
        }));
    }

    protected processGetCurrencies(response: HttpResponseBase): Observable<DropDownListItemModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DropDownListItemModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropDownListItemModel[]>(null as any);
    }

    /**
     * @param amount (optional) 
     * @return Success
     */
    reverseTransaction(id: number, amount?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/Reverse?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReverseTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReverseTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReverseTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param amount (optional) 
     * @return Success
     */
    refundTransaction(id: number, amount?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/Refund?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefundTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    checkRefundLimits(id: number): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/CheckRefundLimits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRefundLimits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRefundLimits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCheckRefundLimits(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    exportTransactions(transactionId?: string | undefined, customerIp?: string | undefined, amount?: number | undefined, currency?: Currency | undefined, confirmedAmount?: number | undefined, returnedAmount?: number | undefined, description?: string | undefined, paymentMerchantId?: string | undefined, paymentMerchantName?: string | undefined, companyIdentificationNumber?: string | undefined, rrn?: string | undefined, createDate_From?: moment.Moment | undefined, createDate_To?: moment.Moment | undefined, status?: PaymentStatus | undefined, userInfo?: string | undefined, isBnpl?: boolean | undefined, terminalNo?: string | undefined, physicalTerminalNo?: string | undefined, initiator?: RecurringPaymentType | undefined, responseCode?: string | undefined, paymentGenId?: string | undefined, parentPaymentGenId?: string | undefined, paymentChannel?: PaymentChannel | undefined, paymentMethod?: PayMethod | undefined, transactionType?: TransactionType | undefined, qRCode?: string | undefined, operatorContact?: string | undefined, hadCancellationProblem?: boolean | undefined, merchantPaymentId?: string | undefined, paymentType?: PaymentType | undefined, paymentObjectType?: PaymentObjectType | undefined, initializerType?: InitializerType | undefined, payByLinkProductId?: number | undefined, payByLinkBasketId?: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Transaction/Export?";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        if (customerIp === null)
            throw new Error("The parameter 'customerIp' cannot be null.");
        else if (customerIp !== undefined)
            url_ += "CustomerIp=" + encodeURIComponent("" + customerIp) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (currency === null)
            throw new Error("The parameter 'currency' cannot be null.");
        else if (currency !== undefined)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        if (confirmedAmount === null)
            throw new Error("The parameter 'confirmedAmount' cannot be null.");
        else if (confirmedAmount !== undefined)
            url_ += "ConfirmedAmount=" + encodeURIComponent("" + confirmedAmount) + "&";
        if (returnedAmount === null)
            throw new Error("The parameter 'returnedAmount' cannot be null.");
        else if (returnedAmount !== undefined)
            url_ += "ReturnedAmount=" + encodeURIComponent("" + returnedAmount) + "&";
        if (description === null)
            throw new Error("The parameter 'description' cannot be null.");
        else if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (paymentMerchantId === null)
            throw new Error("The parameter 'paymentMerchantId' cannot be null.");
        else if (paymentMerchantId !== undefined)
            url_ += "PaymentMerchantId=" + encodeURIComponent("" + paymentMerchantId) + "&";
        if (paymentMerchantName === null)
            throw new Error("The parameter 'paymentMerchantName' cannot be null.");
        else if (paymentMerchantName !== undefined)
            url_ += "PaymentMerchantName=" + encodeURIComponent("" + paymentMerchantName) + "&";
        if (companyIdentificationNumber === null)
            throw new Error("The parameter 'companyIdentificationNumber' cannot be null.");
        else if (companyIdentificationNumber !== undefined)
            url_ += "CompanyIdentificationNumber=" + encodeURIComponent("" + companyIdentificationNumber) + "&";
        if (rrn === null)
            throw new Error("The parameter 'rrn' cannot be null.");
        else if (rrn !== undefined)
            url_ += "Rrn=" + encodeURIComponent("" + rrn) + "&";
        if (createDate_From === null)
            throw new Error("The parameter 'createDate_From' cannot be null.");
        else if (createDate_From !== undefined)
            url_ += "CreateDate.From=" + encodeURIComponent(createDate_From ? "" + createDate_From.toISOString() : "") + "&";
        if (createDate_To === null)
            throw new Error("The parameter 'createDate_To' cannot be null.");
        else if (createDate_To !== undefined)
            url_ += "CreateDate.To=" + encodeURIComponent(createDate_To ? "" + createDate_To.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (userInfo === null)
            throw new Error("The parameter 'userInfo' cannot be null.");
        else if (userInfo !== undefined)
            url_ += "UserInfo=" + encodeURIComponent("" + userInfo) + "&";
        if (isBnpl === null)
            throw new Error("The parameter 'isBnpl' cannot be null.");
        else if (isBnpl !== undefined)
            url_ += "IsBnpl=" + encodeURIComponent("" + isBnpl) + "&";
        if (terminalNo === null)
            throw new Error("The parameter 'terminalNo' cannot be null.");
        else if (terminalNo !== undefined)
            url_ += "TerminalNo=" + encodeURIComponent("" + terminalNo) + "&";
        if (physicalTerminalNo === null)
            throw new Error("The parameter 'physicalTerminalNo' cannot be null.");
        else if (physicalTerminalNo !== undefined)
            url_ += "PhysicalTerminalNo=" + encodeURIComponent("" + physicalTerminalNo) + "&";
        if (initiator === null)
            throw new Error("The parameter 'initiator' cannot be null.");
        else if (initiator !== undefined)
            url_ += "Initiator=" + encodeURIComponent("" + initiator) + "&";
        if (responseCode === null)
            throw new Error("The parameter 'responseCode' cannot be null.");
        else if (responseCode !== undefined)
            url_ += "ResponseCode=" + encodeURIComponent("" + responseCode) + "&";
        if (paymentGenId === null)
            throw new Error("The parameter 'paymentGenId' cannot be null.");
        else if (paymentGenId !== undefined)
            url_ += "PaymentGenId=" + encodeURIComponent("" + paymentGenId) + "&";
        if (parentPaymentGenId === null)
            throw new Error("The parameter 'parentPaymentGenId' cannot be null.");
        else if (parentPaymentGenId !== undefined)
            url_ += "ParentPaymentGenId=" + encodeURIComponent("" + parentPaymentGenId) + "&";
        if (paymentChannel === null)
            throw new Error("The parameter 'paymentChannel' cannot be null.");
        else if (paymentChannel !== undefined)
            url_ += "PaymentChannel=" + encodeURIComponent("" + paymentChannel) + "&";
        if (paymentMethod === null)
            throw new Error("The parameter 'paymentMethod' cannot be null.");
        else if (paymentMethod !== undefined)
            url_ += "PaymentMethod=" + encodeURIComponent("" + paymentMethod) + "&";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (qRCode === null)
            throw new Error("The parameter 'qRCode' cannot be null.");
        else if (qRCode !== undefined)
            url_ += "QRCode=" + encodeURIComponent("" + qRCode) + "&";
        if (operatorContact === null)
            throw new Error("The parameter 'operatorContact' cannot be null.");
        else if (operatorContact !== undefined)
            url_ += "OperatorContact=" + encodeURIComponent("" + operatorContact) + "&";
        if (hadCancellationProblem === null)
            throw new Error("The parameter 'hadCancellationProblem' cannot be null.");
        else if (hadCancellationProblem !== undefined)
            url_ += "HadCancellationProblem=" + encodeURIComponent("" + hadCancellationProblem) + "&";
        if (merchantPaymentId === null)
            throw new Error("The parameter 'merchantPaymentId' cannot be null.");
        else if (merchantPaymentId !== undefined)
            url_ += "MerchantPaymentId=" + encodeURIComponent("" + merchantPaymentId) + "&";
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            url_ += "PaymentType=" + encodeURIComponent("" + paymentType) + "&";
        if (paymentObjectType === null)
            throw new Error("The parameter 'paymentObjectType' cannot be null.");
        else if (paymentObjectType !== undefined)
            url_ += "PaymentObjectType=" + encodeURIComponent("" + paymentObjectType) + "&";
        if (initializerType === null)
            throw new Error("The parameter 'initializerType' cannot be null.");
        else if (initializerType !== undefined)
            url_ += "InitializerType=" + encodeURIComponent("" + initializerType) + "&";
        if (payByLinkProductId === null)
            throw new Error("The parameter 'payByLinkProductId' cannot be null.");
        else if (payByLinkProductId !== undefined)
            url_ += "PayByLinkProductId=" + encodeURIComponent("" + payByLinkProductId) + "&";
        if (payByLinkBasketId === null)
            throw new Error("The parameter 'payByLinkBasketId' cannot be null.");
        else if (payByLinkBasketId !== undefined)
            url_ += "PayByLinkBasketId=" + encodeURIComponent("" + payByLinkBasketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportTransactions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionLogs(id: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/Logs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetTransactionLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionApiLogs(id: number): Observable<ApiLogListItem[]> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/ApiLogs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionApiLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionApiLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiLogListItem[]>;
        }));
    }

    protected processGetTransactionApiLogs(response: HttpResponseBase): Observable<ApiLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiLogListItem[]>(null as any);
    }

    /**
     * @param searchModel_Id (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getTransactionPaymentLogs(id: string, searchModel_Id?: number | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<TransactionPaymentLogResponse> {
        let url_ = this.baseUrl + "/api/Transaction/{id}/PaymentLogs?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (searchModel_Id === null)
            throw new Error("The parameter 'searchModel_Id' cannot be null.");
        else if (searchModel_Id !== undefined)
            url_ += "SearchModel.Id=" + encodeURIComponent("" + searchModel_Id) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionPaymentLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionPaymentLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionPaymentLogResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionPaymentLogResponse>;
        }));
    }

    protected processGetTransactionPaymentLogs(response: HttpResponseBase): Observable<TransactionPaymentLogResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionPaymentLogResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionPaymentLogResponse>(null as any);
    }

    /**
     * @param isSuccessful (optional) 
     * @return Success
     */
    trasnactionChangeStatus(paymentId: number, isSuccessful?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Transaction/{paymentId}/ChangeStatus?";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "isSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrasnactionChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrasnactionChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTrasnactionChangeStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IUserClient {
    /**
     * @param searchModel_Id (optional) 
     * @param searchModel_Username (optional) 
     * @param searchModel_Firstname (optional) 
     * @param searchModel_Lastname (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_PersonalId (optional) 
     * @param searchModel_Email (optional) 
     * @param searchModel_AuthorizationProvider (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_CreatedAtFrom (optional) 
     * @param searchModel_CreatedAtTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryUsers(searchModel_Id?: number | undefined, searchModel_Username?: string | undefined, searchModel_Firstname?: string | undefined, searchModel_Lastname?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_PersonalId?: string | undefined, searchModel_Email?: string | undefined, searchModel_AuthorizationProvider?: AuthorizationProvider | undefined, searchModel_Status?: UserStatus | undefined, searchModel_CreatedAtFrom?: moment.Moment | undefined, searchModel_CreatedAtTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<UserProfileModelPagingResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitUserRegistration(body?: SubmitUserRegistration | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    updateUser(body?: UpdateUser | undefined): Observable<void>;
    /**
     * @return Success
     */
    getUserDetails(id: number): Observable<UserProfileDetailsModel>;
    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void>;
    /**
     * @return Success
     */
    changeUserStatus(id: number, status: UserStatus): Observable<void>;
    /**
     * @return Success
     */
    getUserReferences(id: number): Observable<UserReferenceModel[]>;
    /**
     * @return Success
     */
    getUserInfo(clientNo: string): Observable<UserDetailsModel>;
    /**
     * @param clientNoOrPersonalId (optional) 
     * @param registerUserType (optional) 
     * @return Success
     */
    registerUserFirstPhase(clientNoOrPersonalId?: string | undefined, registerUserType?: RegisterUserType | undefined): Observable<UserRegistrationResponseModel>;
    /**
     * @return Success
     */
    queryUserActionLogs(id: number): Observable<ActionLogListItem[]>;
}

@Injectable()
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_Id (optional) 
     * @param searchModel_Username (optional) 
     * @param searchModel_Firstname (optional) 
     * @param searchModel_Lastname (optional) 
     * @param searchModel_ClientNo (optional) 
     * @param searchModel_PersonalId (optional) 
     * @param searchModel_Email (optional) 
     * @param searchModel_AuthorizationProvider (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_CreatedAtFrom (optional) 
     * @param searchModel_CreatedAtTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryUsers(searchModel_Id?: number | undefined, searchModel_Username?: string | undefined, searchModel_Firstname?: string | undefined, searchModel_Lastname?: string | undefined, searchModel_ClientNo?: string | undefined, searchModel_PersonalId?: string | undefined, searchModel_Email?: string | undefined, searchModel_AuthorizationProvider?: AuthorizationProvider | undefined, searchModel_Status?: UserStatus | undefined, searchModel_CreatedAtFrom?: moment.Moment | undefined, searchModel_CreatedAtTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<UserProfileModelPagingResponse> {
        let url_ = this.baseUrl + "/api/User?";
        if (searchModel_Id === null)
            throw new Error("The parameter 'searchModel_Id' cannot be null.");
        else if (searchModel_Id !== undefined)
            url_ += "SearchModel.Id=" + encodeURIComponent("" + searchModel_Id) + "&";
        if (searchModel_Username === null)
            throw new Error("The parameter 'searchModel_Username' cannot be null.");
        else if (searchModel_Username !== undefined)
            url_ += "SearchModel.Username=" + encodeURIComponent("" + searchModel_Username) + "&";
        if (searchModel_Firstname === null)
            throw new Error("The parameter 'searchModel_Firstname' cannot be null.");
        else if (searchModel_Firstname !== undefined)
            url_ += "SearchModel.Firstname=" + encodeURIComponent("" + searchModel_Firstname) + "&";
        if (searchModel_Lastname === null)
            throw new Error("The parameter 'searchModel_Lastname' cannot be null.");
        else if (searchModel_Lastname !== undefined)
            url_ += "SearchModel.Lastname=" + encodeURIComponent("" + searchModel_Lastname) + "&";
        if (searchModel_ClientNo === null)
            throw new Error("The parameter 'searchModel_ClientNo' cannot be null.");
        else if (searchModel_ClientNo !== undefined)
            url_ += "SearchModel.ClientNo=" + encodeURIComponent("" + searchModel_ClientNo) + "&";
        if (searchModel_PersonalId === null)
            throw new Error("The parameter 'searchModel_PersonalId' cannot be null.");
        else if (searchModel_PersonalId !== undefined)
            url_ += "SearchModel.PersonalId=" + encodeURIComponent("" + searchModel_PersonalId) + "&";
        if (searchModel_Email === null)
            throw new Error("The parameter 'searchModel_Email' cannot be null.");
        else if (searchModel_Email !== undefined)
            url_ += "SearchModel.Email=" + encodeURIComponent("" + searchModel_Email) + "&";
        if (searchModel_AuthorizationProvider === null)
            throw new Error("The parameter 'searchModel_AuthorizationProvider' cannot be null.");
        else if (searchModel_AuthorizationProvider !== undefined)
            url_ += "SearchModel.AuthorizationProvider=" + encodeURIComponent("" + searchModel_AuthorizationProvider) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_CreatedAtFrom === null)
            throw new Error("The parameter 'searchModel_CreatedAtFrom' cannot be null.");
        else if (searchModel_CreatedAtFrom !== undefined)
            url_ += "SearchModel.CreatedAtFrom=" + encodeURIComponent(searchModel_CreatedAtFrom ? "" + searchModel_CreatedAtFrom.toISOString() : "") + "&";
        if (searchModel_CreatedAtTo === null)
            throw new Error("The parameter 'searchModel_CreatedAtTo' cannot be null.");
        else if (searchModel_CreatedAtTo !== undefined)
            url_ += "SearchModel.CreatedAtTo=" + encodeURIComponent(searchModel_CreatedAtTo ? "" + searchModel_CreatedAtTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileModelPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileModelPagingResponse>;
        }));
    }

    protected processQueryUsers(response: HttpResponseBase): Observable<UserProfileModelPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileModelPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileModelPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitUserRegistration(body?: SubmitUserRegistration | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitUserRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitUserRegistration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitUserRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    updateUser(body?: UpdateUser | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getUserDetails(id: number): Observable<UserProfileDetailsModel> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDetailsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDetailsModel>;
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<UserProfileDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDetailsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileDetailsModel>(null as any);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    changeUserStatus(id: number, status: UserStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/User/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUserStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getUserReferences(id: number): Observable<UserReferenceModel[]> {
        let url_ = this.baseUrl + "/api/User/{id}/UserReferences";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserReferences(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserReferenceModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserReferenceModel[]>;
        }));
    }

    protected processGetUserReferences(response: HttpResponseBase): Observable<UserReferenceModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserReferenceModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserReferenceModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getUserInfo(clientNo: string): Observable<UserDetailsModel> {
        let url_ = this.baseUrl + "/api/User/{clientNo}/Info";
        if (clientNo === undefined || clientNo === null)
            throw new Error("The parameter 'clientNo' must be defined.");
        url_ = url_.replace("{clientNo}", encodeURIComponent("" + clientNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailsModel>;
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<UserDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDetailsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsModel>(null as any);
    }

    /**
     * @param clientNoOrPersonalId (optional) 
     * @param registerUserType (optional) 
     * @return Success
     */
    registerUserFirstPhase(clientNoOrPersonalId?: string | undefined, registerUserType?: RegisterUserType | undefined): Observable<UserRegistrationResponseModel> {
        let url_ = this.baseUrl + "/api/User/RegisterUserFirstPhase?";
        if (clientNoOrPersonalId === null)
            throw new Error("The parameter 'clientNoOrPersonalId' cannot be null.");
        else if (clientNoOrPersonalId !== undefined)
            url_ += "ClientNoOrPersonalId=" + encodeURIComponent("" + clientNoOrPersonalId) + "&";
        if (registerUserType === null)
            throw new Error("The parameter 'registerUserType' cannot be null.");
        else if (registerUserType !== undefined)
            url_ += "RegisterUserType=" + encodeURIComponent("" + registerUserType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUserFirstPhase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUserFirstPhase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRegistrationResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRegistrationResponseModel>;
        }));
    }

    protected processRegisterUserFirstPhase(response: HttpResponseBase): Observable<UserRegistrationResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserRegistrationResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRegistrationResponseModel>(null as any);
    }

    /**
     * @return Success
     */
    queryUserActionLogs(id: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/User/{id}/ActionLog";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUserActionLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUserActionLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processQueryUserActionLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }
}

export interface IWebPageClient {
    /**
     * @param searchModel_Address (optional) 
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_Type (optional) 
     * @param searchModel_LimitStatus (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_IsPayByLinkEnabled (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryWebPages(searchModel_Address?: string | undefined, searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_Type?: WebPageMerchantType | undefined, searchModel_LimitStatus?: LimitStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_IsPayByLinkEnabled?: boolean | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<WebPageListItemPagingResponse>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    saveWebPage(body?: UpdateWebPage | undefined): Observable<void>;
    /**
     * @return Success
     */
    getWebPage(id: number): Observable<WebPageDetails>;
    /**
     * @return Success
     */
    getZeroTransactionLogs(id: number): Observable<PaymentLogListItem[]>;
    /**
     * @return Success
     */
    getWebPageLogs(webPageId: number): Observable<ActionLogListItem[]>;
    /**
     * @return Success
     */
    getDefaultPaymentMethods(): Observable<PaymentMethod[]>;
    /**
     * @return Success
     */
    getDefaultCurrencies(): Observable<PaymentCurrency[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addWebPageToCompany(companyId: number, body?: RegisterWebPageRequest | undefined): Observable<IdResponse>;
    /**
     * @return No Content
     */
    changeWebPageStatus(id: number, status: ServiceStatus): Observable<void>;
    /**
     * @return Success
     */
    getPayByLinkValidationUrl(webpageId: number): Observable<void>;
    exportMerchants(address?: string | undefined, companyName?: string | undefined, companyIdentificationNumber?: string | undefined, status?: ServiceStatus | undefined, type?: WebPageMerchantType | undefined, limitStatus?: LimitStatus | undefined, merchantExternalId?: string | undefined, tradeName?: string | undefined, isPayByLinkEnabled?: boolean | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse>;
}

@Injectable()
export class WebPageClient implements IWebPageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchModel_Address (optional) 
     * @param searchModel_CompanyName (optional) 
     * @param searchModel_CompanyIdentificationNumber (optional) 
     * @param searchModel_Status (optional) 
     * @param searchModel_Type (optional) 
     * @param searchModel_LimitStatus (optional) 
     * @param searchModel_MerchantExternalId (optional) 
     * @param searchModel_TradeName (optional) 
     * @param searchModel_IsPayByLinkEnabled (optional) 
     * @param searchModel_DateCreatedFrom (optional) 
     * @param searchModel_DateCreatedTo (optional) 
     * @param sortDir (optional) 
     * @param sortBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    queryWebPages(searchModel_Address?: string | undefined, searchModel_CompanyName?: string | undefined, searchModel_CompanyIdentificationNumber?: string | undefined, searchModel_Status?: ServiceStatus | undefined, searchModel_Type?: WebPageMerchantType | undefined, searchModel_LimitStatus?: LimitStatus | undefined, searchModel_MerchantExternalId?: string | undefined, searchModel_TradeName?: string | undefined, searchModel_IsPayByLinkEnabled?: boolean | undefined, searchModel_DateCreatedFrom?: moment.Moment | undefined, searchModel_DateCreatedTo?: moment.Moment | undefined, sortDir?: string | undefined, sortBy?: string | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<WebPageListItemPagingResponse> {
        let url_ = this.baseUrl + "/api/WebPage?";
        if (searchModel_Address === null)
            throw new Error("The parameter 'searchModel_Address' cannot be null.");
        else if (searchModel_Address !== undefined)
            url_ += "SearchModel.Address=" + encodeURIComponent("" + searchModel_Address) + "&";
        if (searchModel_CompanyName === null)
            throw new Error("The parameter 'searchModel_CompanyName' cannot be null.");
        else if (searchModel_CompanyName !== undefined)
            url_ += "SearchModel.CompanyName=" + encodeURIComponent("" + searchModel_CompanyName) + "&";
        if (searchModel_CompanyIdentificationNumber === null)
            throw new Error("The parameter 'searchModel_CompanyIdentificationNumber' cannot be null.");
        else if (searchModel_CompanyIdentificationNumber !== undefined)
            url_ += "SearchModel.CompanyIdentificationNumber=" + encodeURIComponent("" + searchModel_CompanyIdentificationNumber) + "&";
        if (searchModel_Status === null)
            throw new Error("The parameter 'searchModel_Status' cannot be null.");
        else if (searchModel_Status !== undefined)
            url_ += "SearchModel.Status=" + encodeURIComponent("" + searchModel_Status) + "&";
        if (searchModel_Type === null)
            throw new Error("The parameter 'searchModel_Type' cannot be null.");
        else if (searchModel_Type !== undefined)
            url_ += "SearchModel.Type=" + encodeURIComponent("" + searchModel_Type) + "&";
        if (searchModel_LimitStatus === null)
            throw new Error("The parameter 'searchModel_LimitStatus' cannot be null.");
        else if (searchModel_LimitStatus !== undefined)
            url_ += "SearchModel.LimitStatus=" + encodeURIComponent("" + searchModel_LimitStatus) + "&";
        if (searchModel_MerchantExternalId === null)
            throw new Error("The parameter 'searchModel_MerchantExternalId' cannot be null.");
        else if (searchModel_MerchantExternalId !== undefined)
            url_ += "SearchModel.MerchantExternalId=" + encodeURIComponent("" + searchModel_MerchantExternalId) + "&";
        if (searchModel_TradeName === null)
            throw new Error("The parameter 'searchModel_TradeName' cannot be null.");
        else if (searchModel_TradeName !== undefined)
            url_ += "SearchModel.TradeName=" + encodeURIComponent("" + searchModel_TradeName) + "&";
        if (searchModel_IsPayByLinkEnabled === null)
            throw new Error("The parameter 'searchModel_IsPayByLinkEnabled' cannot be null.");
        else if (searchModel_IsPayByLinkEnabled !== undefined)
            url_ += "SearchModel.IsPayByLinkEnabled=" + encodeURIComponent("" + searchModel_IsPayByLinkEnabled) + "&";
        if (searchModel_DateCreatedFrom === null)
            throw new Error("The parameter 'searchModel_DateCreatedFrom' cannot be null.");
        else if (searchModel_DateCreatedFrom !== undefined)
            url_ += "SearchModel.DateCreatedFrom=" + encodeURIComponent(searchModel_DateCreatedFrom ? "" + searchModel_DateCreatedFrom.toISOString() : "") + "&";
        if (searchModel_DateCreatedTo === null)
            throw new Error("The parameter 'searchModel_DateCreatedTo' cannot be null.");
        else if (searchModel_DateCreatedTo !== undefined)
            url_ += "SearchModel.DateCreatedTo=" + encodeURIComponent(searchModel_DateCreatedTo ? "" + searchModel_DateCreatedTo.toISOString() : "") + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "SortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryWebPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryWebPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebPageListItemPagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebPageListItemPagingResponse>;
        }));
    }

    protected processQueryWebPages(response: HttpResponseBase): Observable<WebPageListItemPagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebPageListItemPagingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebPageListItemPagingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    saveWebPage(body?: UpdateWebPage | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WebPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveWebPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveWebPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveWebPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getWebPage(id: number): Observable<WebPageDetails> {
        let url_ = this.baseUrl + "/api/WebPage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWebPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWebPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebPageDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebPageDetails>;
        }));
    }

    protected processGetWebPage(response: HttpResponseBase): Observable<WebPageDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebPageDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebPageDetails>(null as any);
    }

    /**
     * @return Success
     */
    getZeroTransactionLogs(id: number): Observable<PaymentLogListItem[]> {
        let url_ = this.baseUrl + "/api/WebPage/{id}/ZeroTransactionLogs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZeroTransactionLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZeroTransactionLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentLogListItem[]>;
        }));
    }

    protected processGetZeroTransactionLogs(response: HttpResponseBase): Observable<PaymentLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentLogListItem[]>(null as any);
    }

    /**
     * @return Success
     */
    getWebPageLogs(webPageId: number): Observable<ActionLogListItem[]> {
        let url_ = this.baseUrl + "/api/WebPage/{webPageId}/Logs";
        if (webPageId === undefined || webPageId === null)
            throw new Error("The parameter 'webPageId' must be defined.");
        url_ = url_.replace("{webPageId}", encodeURIComponent("" + webPageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWebPageLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWebPageLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionLogListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionLogListItem[]>;
        }));
    }

    protected processGetWebPageLogs(response: HttpResponseBase): Observable<ActionLogListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActionLogListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionLogListItem[]>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultPaymentMethods(): Observable<PaymentMethod[]> {
        let url_ = this.baseUrl + "/api/WebPage/GetDefaultPaymentMethods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultPaymentMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethod[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethod[]>;
        }));
    }

    protected processGetDefaultPaymentMethods(response: HttpResponseBase): Observable<PaymentMethod[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentMethod[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethod[]>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultCurrencies(): Observable<PaymentCurrency[]> {
        let url_ = this.baseUrl + "/api/WebPage/GetDefaultCurrencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCurrency[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCurrency[]>;
        }));
    }

    protected processGetDefaultCurrencies(response: HttpResponseBase): Observable<PaymentCurrency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentCurrency[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentCurrency[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWebPageToCompany(companyId: number, body?: RegisterWebPageRequest | undefined): Observable<IdResponse> {
        let url_ = this.baseUrl + "/api/WebPage/Company/{companyId}/WebPageRegister";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWebPageToCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWebPageToCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdResponse>;
        }));
    }

    protected processAddWebPageToCompany(response: HttpResponseBase): Observable<IdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdResponse>(null as any);
    }

    /**
     * @return No Content
     */
    changeWebPageStatus(id: number, status: ServiceStatus): Observable<void> {
        let url_ = this.baseUrl + "/api/WebPage/{id}/Status/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeWebPageStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeWebPageStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeWebPageStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPayByLinkValidationUrl(webpageId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/WebPage/{webpageId}/paybylinkvalidationurl";
        if (webpageId === undefined || webpageId === null)
            throw new Error("The parameter 'webpageId' must be defined.");
        url_ = url_.replace("{webpageId}", encodeURIComponent("" + webpageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayByLinkValidationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayByLinkValidationUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPayByLinkValidationUrl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    exportMerchants(address?: string | undefined, companyName?: string | undefined, companyIdentificationNumber?: string | undefined, status?: ServiceStatus | undefined, type?: WebPageMerchantType | undefined, limitStatus?: LimitStatus | undefined, merchantExternalId?: string | undefined, tradeName?: string | undefined, isPayByLinkEnabled?: boolean | undefined, dateCreatedFrom?: moment.Moment | undefined, dateCreatedTo?: moment.Moment | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WebPage/Export?";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (companyName === null)
            throw new Error("The parameter 'companyName' cannot be null.");
        else if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (companyIdentificationNumber === null)
            throw new Error("The parameter 'companyIdentificationNumber' cannot be null.");
        else if (companyIdentificationNumber !== undefined)
            url_ += "CompanyIdentificationNumber=" + encodeURIComponent("" + companyIdentificationNumber) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (limitStatus === null)
            throw new Error("The parameter 'limitStatus' cannot be null.");
        else if (limitStatus !== undefined)
            url_ += "LimitStatus=" + encodeURIComponent("" + limitStatus) + "&";
        if (merchantExternalId === null)
            throw new Error("The parameter 'merchantExternalId' cannot be null.");
        else if (merchantExternalId !== undefined)
            url_ += "MerchantExternalId=" + encodeURIComponent("" + merchantExternalId) + "&";
        if (tradeName === null)
            throw new Error("The parameter 'tradeName' cannot be null.");
        else if (tradeName !== undefined)
            url_ += "TradeName=" + encodeURIComponent("" + tradeName) + "&";
        if (isPayByLinkEnabled === null)
            throw new Error("The parameter 'isPayByLinkEnabled' cannot be null.");
        else if (isPayByLinkEnabled !== undefined)
            url_ += "IsPayByLinkEnabled=" + encodeURIComponent("" + isPayByLinkEnabled) + "&";
        if (dateCreatedFrom === null)
            throw new Error("The parameter 'dateCreatedFrom' cannot be null.");
        else if (dateCreatedFrom !== undefined)
            url_ += "DateCreatedFrom=" + encodeURIComponent(dateCreatedFrom ? "" + dateCreatedFrom.toISOString() : "") + "&";
        if (dateCreatedTo === null)
            throw new Error("The parameter 'dateCreatedTo' cannot be null.");
        else if (dateCreatedTo !== undefined)
            url_ += "DateCreatedTo=" + encodeURIComponent(dateCreatedTo ? "" + dateCreatedTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/csv"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportMerchants(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface AccountDetails {
    permissions?: string[] | undefined;
    name?: string | undefined;
}

export enum ActionEntity {
    Company = 1,
    WebPage = 2,
    QrPayment = 3,
    QrMerchant = 4,
    User = 5,
    Payment = 6,
    FaceMerchant = 7,
    FaceTerminal = 8,
    PayByLinkProduct = 9,
    PayByLinkBasket = 10,
    MerchantLogo = 11,
    FaceDevice = 12,
    CallBack = 13,
    PosQRTerminal = 14,
    PosQRMerchant = 15,
}

export interface ActionLogField {
    readonly displayName?: string | undefined;
    name?: string | undefined;
    originalValue?: string | undefined;
    newValue?: string | undefined;
}

export interface ActionLogListItem {
    id?: number;
    actionEntity?: string | undefined;
    actionType?: string | undefined;
    actionSource?: string | undefined;
    actionEntityPk?: number;
    userName?: string | undefined;
    dateCreated?: moment.Moment;
    fields?: ActionLogField[] | undefined;
}

export interface ActionLogListItemPagingResponse {
    totalCount?: number;
    data?: ActionLogListItem[] | undefined;
}

export enum ActionSource {
    TPayAdmin = 1,
    TPayWeb = 2,
}

export enum ActionType {
    Create = 1,
    Update = 2,
    Delete = 3,
    ChangeStatus = 4,
    AddUser = 101,
    ChangeUserRole = 102,
    AcceptUserRole = 103,
    DeclineUserRole = 104,
    DeleteUser = 105,
    AddUserCompanyPaymentMerchant = 106,
    DeleteUserCompanyPaymentMerchant = 107,
    AddCashDesk = 201,
    DeleteCashDesk = 202,
    ChangeCashDeskName = 203,
    AddCashier = 204,
    DeleteCashier = 205,
    AddDevice = 206,
    DeleteDevice = 207,
    LinkExistingPrintedQRToCashDesk = 208,
    DeleteLinkToExistingPrintedQR = 209,
    ReversePayment = 301,
    RefundPayment = 302,
    ManuallyChangePayment = 303,
    AcceptInstallment = 304,
    CancelInstallment = 305,
    ReverseAttemptByMerchant = 306,
    RefundAttemptByMerchant = 307,
    AddPaymentMethod = 401,
    DeletePaymentMethod = 402,
    AddCurrency = 403,
    DeleteCurrency = 404,
    ItemAddToBasket = 700,
    DeleteBasket = 701,
    BasketPriceChanged = 703,
    RemoveItemFromBasket = 704,
    BasketCreated = 705,
    BasketNameChanged = 706,
    BasketCodeChanged = 707,
    BasketDescriptionChanged = 708,
    BasketPayMethodChanged = 709,
    BasketExpirationDateChanged = 710,
    ProductCreated = 800,
    ProductQuantityChanged = 801,
    ProductPriceChanged = 802,
    ProductIsReusableChanged = 803,
    ProductCodeChanged = 804,
    ProductDescriptionChanged = 805,
    ProductPhotoChanged = 806,
    ProductDeleted = 807,
    ProductActivated = 808,
    ProductInActivated = 809,
    ProductNameChanged = 810,
    ProductPayMethodChanged = 811,
    MerchantLogoApprove = 900,
    MerchantLogoDecline = 901,
    MerchantUploadLogo = 902,
    MerchantLogoDeletedAutomatically = 903,
    MerchantLogoDeletedManually = 904,
    CallBackApprove = 1000,
    CallBackDecline = 1001,
}

export interface AddCashDesk {
    cashDeskName?: string | undefined;
    cashierFirstName?: string | undefined;
    cashierLastName?: string | undefined;
    cashierPhoneNumber?: string | undefined;
}

export interface AddCashDeskWithDevice {
    cashDeskName?: string | undefined;
    cashDeskDeviceSerialNumber?: string | undefined;
    cashDeskDeviceSimCardNumber?: string | undefined;
}

export interface AddCashDeskWithExistingQr {
    cashDeskName?: string | undefined;
    existingQrCode?: string | undefined;
    cashierFirstName?: string | undefined;
    cashierLastName?: string | undefined;
    cashierPhoneNumber?: string | undefined;
}

export interface AddCashierToCashDesk {
    cashierFirstName?: string | undefined;
    cashierLastName?: string | undefined;
    cashierPhoneNumber?: string | undefined;
}

export interface AddDeviceToCashDesk {
    deviceSerialNumber?: string | undefined;
    deviceSimCardNumber?: string | undefined;
}

export interface AddUserToCompany {
    clientNo?: string | undefined;
    role?: UserRole;
    paymentMerchantIds?: number[] | undefined;
}

export interface ApiLogListItem {
    id?: number;
    clientIp?: string | undefined;
    query?: string | undefined;
    method?: string | undefined;
    statusCode?: number;
    requestTime?: moment.Moment;
    requestHeaders?: string | undefined;
    request?: string | undefined;
    responseTime?: moment.Moment;
    response?: string | undefined;
}

export interface ApiResponse {
    message?: string | undefined;
    validationErrors?: { [key: string]: string[]; } | undefined;
}

export enum AuthorizationProvider {
    TbcOnline = 0,
    TPay = 1,
    None = 2,
}

export interface BasketDetails {
    id?: number;
    dateCreated?: moment.Moment;
    dateModified?: moment.Moment;
    name?: string | undefined;
    code?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    paymentMerchantId?: number;
    status?: string | undefined;
    expirationDate?: moment.Moment;
    creator?: string | undefined;
    payMethods?: PayMethod[] | undefined;
    readonly payMethodNames?: string[] | undefined;
    merchantTradeName?: string | undefined;
    merchantExternalId?: string | undefined;
    basketItems?: BasketItemDetails[] | undefined;
}

export interface BasketItemDetails {
    productId?: number;
    productName?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    quantity?: number;
    fileName?: string | undefined;
}

export interface BasketListItem {
    id?: number;
    dateCreated?: moment.Moment;
    name?: string | undefined;
    code?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    status?: string | undefined;
    expirationDate?: moment.Moment;
    creator?: string | undefined;
    merchantTradeName?: string | undefined;
    merchantExternalId?: string | undefined;
}

export interface BasketListItemPagingResponse {
    totalCount?: number;
    data?: BasketListItem[] | undefined;
}

export interface CallBackDto {
    readonly isPrimary?: boolean;
    readonly host?: string | undefined;
    readonly url?: string | undefined;
}

export enum CallBackStatus {
    Pending = 0,
    Active = 1,
    Declined = 2,
    Deleted = 3,
}

export interface CallBackVm {
    id?: number;
    url?: string | undefined;
    host?: string | undefined;
    webAddress?: string | undefined;
    status?: CallBackStatus;
    readonly statusName?: string | undefined;
    merchantExternalId?: string | undefined;
    dateModified?: moment.Moment;
    comment?: string | undefined;
}

export interface CallBackVmPagingResponse {
    totalCount?: number;
    data?: CallBackVm[] | undefined;
}

export interface CardDetailsModel {
    clientNo?: string | undefined;
    personalId?: string | undefined;
    cardOwnerFullName?: string | undefined;
    phoneNumber?: string | undefined;
    product?: string | undefined;
    cardMask?: string | undefined;
    cardStatus?: string | undefined;
    designId?: string | undefined;
    isPrimary?: boolean | undefined;
    createdAt?: moment.Moment | undefined;
    deletedAt?: moment.Moment | undefined;
    transactionLogs?: CardTransactionLog[] | undefined;
    cardType?: string | undefined;
}

export enum CardStatus {
    Unknown = 0,
    Ok = 1,
    Expired = 3,
    Disabled = 5,
    BlockedInUFC = 6,
    Deleted = 7,
}

export interface CardTransactionLog {
    operationDate?: moment.Moment | undefined;
    paymentLogType?: string | undefined;
    requestBody?: string | undefined;
    responseBody?: string | undefined;
    amount?: number | undefined;
    description?: string | undefined;
}

export interface CardsListItem {
    id?: number;
    userFullName?: string | undefined;
    phoneNumber?: string | undefined;
    clientNo?: string | undefined;
    personalId?: string | undefined;
    product?: string | undefined;
    cardType?: string | undefined;
    cardMask?: string | undefined;
    cardStatus?: string | undefined;
    designId?: string | undefined;
    isPrimary?: boolean | undefined;
    createdAt?: moment.Moment | undefined;
}

export interface CardsListItemPagingResponse {
    totalCount?: number;
    data?: CardsListItem[] | undefined;
}

export interface ChangeUserRoleAndPaymentMerchants {
    userId?: number;
    role?: UserRole;
    paymentMerchantIds?: number[] | undefined;
}

export interface ChildWebPageDetails {
    webAddress?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
}

export interface ClientSecretModel {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
}

export interface CompanyDetailsFaceMerchant {
    id?: number;
    externalMerchantId?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeName?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface CompanyDetailsGenDirector {
    id?: number;
    firstname?: string | undefined;
    lastname?: string | undefined;
    personalNumber?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export interface CompanyDetailsPosQRMerchant {
    id?: number;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
}

export interface CompanyDetailsPosQRTerminal {
    id?: number;
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    status?: PosQRTerminalStatus;
    readonly statusName?: string | undefined;
    posQrMerchantId?: number;
    paymentMerchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    merchantStatus?: ServiceStatus;
}

export interface CompanyDetailsQRMerchant {
    id?: number;
    externalMerchantId?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface CompanyDetailsQRPayment {
    id?: number;
    externalMerchantId?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface CompanyDetailsResponseModel {
    details?: CompanyGeneralDetails;
    users?: CompanyDetailsUser[] | undefined;
    webPages?: WebPageDetails[] | undefined;
    qrPayments?: CompanyDetailsQRPayment[] | undefined;
    qrMerchants?: CompanyDetailsQRMerchant[] | undefined;
    faceMerchants?: CompanyDetailsFaceMerchant[] | undefined;
    posQRMerchants?: CompanyDetailsPosQRMerchant[] | undefined;
    posQRTerminals?: CompanyDetailsPosQRTerminal[] | undefined;
}

export interface CompanyDetailsUser {
    firstname?: string | undefined;
    lastname?: string | undefined;
    clientNo?: string | undefined;
    phoneNumber?: string | undefined;
    role?: string | undefined;
    requestedRole?: string | undefined;
    requestedMerchantIds?: string | undefined;
    status?: string | undefined;
    userStatus?: string | undefined;
    userId?: number;
    externalUserId?: string | undefined;
}

export interface CompanyGeneralDetails {
    name?: string | undefined;
    juridicalAddress?: string | undefined;
    id?: number;
    identificationNumber?: string | undefined;
    clientNo?: string | undefined;
    companyEmail?: string | undefined;
    phoneNumber?: string | undefined;
    status?: CompanyStatus;
    readonly statusName?: string | undefined;
    dateCreated?: moment.Moment;
    generalDirector?: CompanyDetailsGenDirector;
}

export interface CompanyModel {
    id?: number;
    juridicalName?: string | undefined;
    identificationNumber?: string | undefined;
    companyEmail?: string | undefined;
    dateCreated?: moment.Moment;
    adminCreator?: string | undefined;
}

export interface CompanyModelPagingResponse {
    totalCount?: number;
    data?: CompanyModel[] | undefined;
}

export enum CompanyStatus {
    Pending = 0,
    Accepted = 1,
    Declined = 2,
    Blocked = 3,
}

export enum CreatorType {
    Merchant = 0,
    AutoGenerated = 1,
}

export enum CreditCardStatus {
    Unknown = 0,
    Credit = 1,
    Debit = 2,
}

export enum Currency {
    None = 0,
    GEL = 1,
    USD = 2,
    EUR = 3,
}

export interface DetailsPosQRTerminal {
    id?: number;
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    isBnplEnabled?: boolean;
    status?: PosQRTerminalStatus;
    readonly posQRTerminalStatusName?: string | undefined;
    dateCreated?: moment.Moment;
    posQrMerchantId?: number;
    paymentMerchantExternalId?: string | undefined;
    companyJuridicalName?: string | undefined;
    tradeName?: string | undefined;
    merchantStatus?: ServiceStatus;
    mccCodeId?: number | undefined;
    canRefund?: boolean;
}

export interface DropDownListItemModel {
    id?: number;
    name?: string | undefined;
}

export interface FaceDeviceDetails {
    id?: number;
    dateCreated?: moment.Moment;
    deviceId?: string | undefined;
    deviceStatus?: FaceDeviceStatus;
    readonly deviceStatusName?: string | undefined;
    comment?: string | undefined;
    faceTerminalNo?: string | undefined;
    paymentMerchantTradeName?: string | undefined;
    companyJuridicalName?: string | undefined;
}

export interface FaceDeviceListItem {
    id?: number;
    dateCreated?: moment.Moment;
    deviceId?: string | undefined;
    faceDeviceStatus?: FaceDeviceStatus;
    readonly faceDeviceStatusName?: string | undefined;
    faceTerminalNo?: string | undefined;
}

export interface FaceDeviceListItemPagingResponse {
    totalCount?: number;
    data?: FaceDeviceListItem[] | undefined;
}

export interface FaceDeviceRegister {
    deviceId?: string | undefined;
}

export enum FaceDeviceStatus {
    Active = 0,
    Free = 1,
    Blocked = 2,
    Lost = 3,
}

export interface FaceMerchantDetails {
    id?: number;
    companyIdentificationNumber?: string | undefined;
    mccCodeId?: number | undefined;
    paymentMerchantExternalId?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    companyJuridicalName?: string | undefined;
    tradeName?: string | undefined;
    businessField?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    refundLimitPerMonth?: number | undefined;
    refundLimitPerDay?: number | undefined;
    dateCreated?: moment.Moment;
    canRefund?: boolean | undefined;
    faceTerminals?: FaceTerminalModel[] | undefined;
}

export interface FaceMerchantListItem {
    id?: number;
    companyName?: string | undefined;
    externalMerchantId?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeName?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface FaceMerchantListItemPagingResponse {
    totalCount?: number;
    data?: FaceMerchantListItem[] | undefined;
}

export interface FaceMerchantRegister {
    businessField?: string | undefined;
    tradeName?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    canRefund?: boolean;
    mccCodeId?: number | undefined;
    merchantExternalId?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    refundLimit?: MerchantRefundLimitDto;
}

export interface FaceTerminalDetails {
    id?: number;
    companyIdentificationNumber?: string | undefined;
    mccCodeId?: number | undefined;
    paymentMerchantId?: number;
    paymentMerchantExternalId?: string | undefined;
    terminalStatus?: FaceTerminalStatus;
    readonly terminalStatusName?: string | undefined;
    comment?: string | undefined;
    companyJuridicalName?: string | undefined;
    tradeName?: string | undefined;
    businessField?: string | undefined;
    description?: string | undefined;
    accountNumber?: string | undefined;
    emailForRecords?: string | undefined;
    sendingPeriod?: string | undefined;
    dateCreated?: moment.Moment;
    canRefund?: boolean | undefined;
    readonly terminalNo?: string | undefined;
    deviceId?: string | undefined;
    gps?: string | undefined;
}

export interface FaceTerminalListItem {
    id?: number;
    companyName?: string | undefined;
    externalMerchantId?: string | undefined;
    terminalNo?: string | undefined;
    deviceId?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    faceTerminalStatus?: FaceTerminalStatus;
    readonly faceTerminalStatusName?: string | undefined;
    tradeName?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface FaceTerminalListItemPagingResponse {
    totalCount?: number;
    data?: FaceTerminalListItem[] | undefined;
}

export interface FaceTerminalModel {
    terminalNo?: string | undefined;
    deviceId?: string | undefined;
    dateCreated?: moment.Moment;
    terminalStatus?: FaceTerminalStatus;
    readonly terminalStatusName?: string | undefined;
}

export interface FaceTerminalRegister {
    terminalNo?: string | undefined;
}

export enum FaceTerminalStatus {
    Active = 0,
    Deleted = 1,
    Blocked = 2,
    Lost = 3,
}

export interface GenerateQRGroupRequestModel {
    quantity?: number | undefined;
}

export interface GenerateQRGroupResponseModel {
    qrGroupId?: string | undefined;
}

export interface IdResponse {
    id?: number;
}

export enum InitializerType {
    Regular = 0,
    Basket = 1,
    Product = 2,
}

export interface IsMerchantAcceptedDto {
    isMerchantAccepted?: boolean;
    id?: number;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
}

export enum LimitStatus {
    Production = 0,
    WaitingRiskConfirm = 1,
    Test = 2,
}

export interface ListItemPosQRTerminal {
    id?: number;
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    isBnplEnabled?: boolean;
    status?: PosQRTerminalStatus;
    readonly statusName?: string | undefined;
    dateCreated?: moment.Moment;
    posQRMerchantId?: number;
    companyName?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    externalMerchantId?: string | undefined;
    tradeName?: string | undefined;
    merchantStatus?: ServiceStatus;
}

export interface ListItemPosQRTerminalPagingResponse {
    totalCount?: number;
    data?: ListItemPosQRTerminal[] | undefined;
}

export enum LogoStatus {
    Waiting = 0,
    Approved = 1,
    Declined = 2,
    Deleted = 3,
}

export interface MasterWebPageDetails {
    masterWebPageId?: number | undefined;
    webAddress?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
}

export interface MccCode {
    id?: number;
    code?: string | undefined;
    descriptionKa?: string | undefined;
    descriptionEn?: string | undefined;
}

export interface MerchantLogoItem {
    id?: number;
    webAddress?: string | undefined;
    status?: LogoStatus;
    readonly statusName?: string | undefined;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    dateCreated?: moment.Moment;
    logoUrl?: string | undefined;
    paymentMerchantId?: number;
    comment?: string | undefined;
}

export interface MerchantLogoItemPagingResponse {
    totalCount?: number;
    data?: MerchantLogoItem[] | undefined;
}

export interface MerchantPaymentLimit {
    transaction?: number | undefined;
    daily?: number | undefined;
    monthly?: number | undefined;
}

export interface MerchantPaymentLimitDto {
    transaction?: number | undefined;
    day?: number | undefined;
    month?: number | undefined;
}

export interface MerchantRefundLimit {
    daily?: number | undefined;
    monthly?: number | undefined;
}

export interface MerchantRefundLimitDto {
    day?: number | undefined;
    month?: number | undefined;
}

export enum MerchantType {
    Unknown = 0,
    WebPage = 1,
    QrPayment = 2,
    QrMerchant = 3,
    FaceMerchant = 4,
    PosQrMerchant = 5,
}

export enum MultipleChoiceListActionType {
    Add = 0,
    Remove = 1,
}

export enum PayMethod {
    PrintedQR = 1,
    MobileQR = 2,
    MerchantQR = 3,
    TbcCheckoutQR = 4,
    TbcCheckoutCard = 5,
    TbcCheckoutErtguli = 6,
    TbcCheckoutLogin = 7,
    TbcCheckoutInstallment = 8,
    TbcCheckoutApplePay = 9,
    TbcCheckoutFacePay = 10,
    Recurring = 11,
    TbcCheckoutPartialErtguli = 12,
    PosQR = 13,
    None = -1,
}

export enum PaymentChannel {
    TbcMobile = 0,
    Tpay = 1,
}

export interface PaymentCurrency {
    currency?: Currency;
    name?: string | undefined;
    isEnabled?: boolean;
}

export interface PaymentLogListItem {
    operationDate?: moment.Moment;
    paymentLogType?: string | undefined;
    requestBody?: string | undefined;
    responseBody?: string | undefined;
    amount?: number;
    description?: string | undefined;
}

export interface PaymentLogListItemPagingResponse {
    totalCount?: number;
    data?: PaymentLogListItem[] | undefined;
}

export interface PaymentMerchantData {
    id?: number;
    name?: string | undefined;
    merchantType?: string | undefined;
    isEnabled?: boolean;
}

export interface PaymentMethod {
    payMethod?: PayMethod;
    name?: string | undefined;
    isEnabled?: boolean;
}

export enum PaymentObjectType {
    Regular = 0,
    Parent = 1,
    Child = 2,
}

export enum PaymentStatus {
    Created = 0,
    Processing = 1,
    Succeeded = 3,
    Failed = 4,
    AutoReversalProcessing = 7,
    AutoReversed = 8,
    Expired = 9,
    CancelPaymentProcessing = 10,
    PartiallyReturned = 11,
    Returned = 12,
    WaitingConfirm = 13,
    PaymentCompletionProcessing = 14,
    ExpirationProcessing = 15,
    Deleted = -1,
}

export enum PaymentType {
    Pay = 0,
    CardRegistration = 1,
}

export interface PosQRDetails {
    tradeName?: string | undefined;
    status?: ServiceStatus;
    mccCodeId?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    limitPerTransaction?: number | undefined;
    merchantExternalId?: string | undefined;
    readonly statusName?: string | undefined;
    terminals?: PosQRTerminalsViewModel[] | undefined;
}

export interface PosQRListItem {
    id?: number;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    status?: ServiceStatus;
    dateCreated?: moment.Moment;
    readonly statusName?: string | undefined;
}

export interface PosQRListItemPagingResponse {
    totalCount?: number;
    data?: PosQRListItem[] | undefined;
}

export enum PosQRTerminalStatus {
    Pending = 0,
    Accepted = 1,
    Declined = 2,
    Blocked = 3,
}

export interface PosQRTerminalsViewModel {
    id?: number;
    name?: string | undefined;
    terminalNo?: string | undefined;
    status?: PosQRTerminalStatus;
    readonly statusName?: string | undefined;
    isBnpl?: boolean;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export interface ProductDetails {
    id?: number;
    dateCreated?: moment.Moment;
    dateModified?: moment.Moment;
    name?: string | undefined;
    description?: string | undefined;
    code?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    maxQuantityPerBuy?: number;
    maxTotalQuantity?: number;
    paymentMerchantId?: number;
    productType?: string | undefined;
    isReusable?: boolean;
    status?: string | undefined;
    payMethods?: PayMethod[] | undefined;
    readonly payMethodNames?: string[] | undefined;
    fileName?: string | undefined;
    image?: string | undefined;
    merchantTradeName?: string | undefined;
    merchantExternalId?: string | undefined;
}

export interface ProductListItem {
    id?: number;
    dateCreated?: moment.Moment;
    name?: string | undefined;
    code?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    status?: string | undefined;
    productType?: string | undefined;
    maxQuantityPerBuy?: number;
    maxTotalQuantity?: number;
    isReusable?: boolean;
    isReusableText?: string | undefined;
    fileName?: string | undefined;
    merchantTradeName?: string | undefined;
    merchantExternalId?: string | undefined;
}

export interface ProductListItemPagingResponse {
    totalCount?: number;
    data?: ProductListItem[] | undefined;
}

export enum ProductType {
    Physical = 0,
    Service = 1,
}

export interface QRMerchantDetails {
    id?: number;
    companyIdentificationNumber?: string | undefined;
    mccCodeId?: number | undefined;
    paymentMerchantExternalId?: string | undefined;
    clientSecret?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    companyJuridicalName?: string | undefined;
    tradeNameKa?: string | undefined;
    tradeNameEn?: string | undefined;
    businessField?: string | undefined;
    description?: string | undefined;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    refundLimit?: MerchantRefundLimit;
    accountNumber?: string | undefined;
    emailForRecords?: string | undefined;
    sendingPeriod?: string | undefined;
    dateCreated?: moment.Moment;
    canRefund?: boolean | undefined;
}

export interface QRMerchantListItem {
    id?: number;
    companyName?: string | undefined;
    externalMerchantId?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface QRMerchantListItemPagingResponse {
    totalCount?: number;
    data?: QRMerchantListItem[] | undefined;
}

export interface QRPaymentDetails {
    id?: number;
    companyId?: number;
    mccCodeId?: number | undefined;
    paymentMerchantExternalId?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    paymentType?: QRPaymentType;
    isPrintedQR?: boolean;
    isMobileQR?: boolean;
    companyJuridicalName?: string | undefined;
    tradeNameKa?: string | undefined;
    tradeNameEn?: string | undefined;
    businessField?: string | undefined;
    description?: string | undefined;
    paymentLimits?: MerchantPaymentLimit;
    refundLimit?: MerchantRefundLimit;
    accountNumber?: string | undefined;
    emailForRecords?: string | undefined;
    sendingPeriod?: string | undefined;
    dateCreated?: moment.Moment;
    qrCashDesks?: QrCashDeskModel[] | undefined;
    canRefund?: boolean | undefined;
}

export interface QRPaymentListItem {
    id?: number;
    companyName?: string | undefined;
    externalMerchantId?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    dateCreated?: moment.Moment;
}

export interface QRPaymentListItemPagingResponse {
    totalCount?: number;
    data?: QRPaymentListItem[] | undefined;
}

export enum QRPaymentType {
    PrintedQR = 1,
    MobileQR = 2,
    MerchantQR = 4,
    TbcCheckoutQR = 8,
    PosQR = 16,
}

export interface QrCashDeskDeviceModel {
    id?: number;
    type?: string | undefined;
    serialNumber?: string | undefined;
    simCardNumber?: string | undefined;
}

export interface QrCashDeskModel {
    qrCode?: string | undefined;
    code?: string | undefined;
    qrImage?: string | undefined;
    id?: number;
    cashDeskName?: string | undefined;
    cashiers?: QrCashDeskUserModel[] | undefined;
    generatorUserId?: number | undefined;
    device?: QrCashDeskDeviceModel;
}

export interface QrCashDeskUserModel {
    cashDeskCashierId?: number;
    role?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    phoneNumber?: string | undefined;
}

export enum QrPrintType {
    Standard150x210 = 1,
    BlueBackground150x210 = 2,
    BlueBackground120x150 = 3,
    BlueBackground90x120 = 4,
    BlueBackground43x65 = 5,
    OnlyQr25x25 = 6,
}

export interface RecurringCardDetailsModel {
    recId?: string | undefined;
    expiryDate?: moment.Moment;
    cardMask?: string | undefined;
    status?: string | undefined;
    cardType?: string | undefined;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    paymentGenId?: string | undefined;
    merchantPaymentId?: string | undefined;
    dateCreated?: moment.Moment | undefined;
    dateModified?: moment.Moment | undefined;
    recurringType?: string | undefined;
}

export enum RecurringCardStatus {
    Create = 0,
    Active = 1,
    Expired = 2,
    Deleted = -1,
}

export enum RecurringCardType {
    Regular = 0,
    TBC = 1,
    Unknown = -1,
}

export interface RecurringCardsListItem {
    id?: number;
    merchantExternalId?: string | undefined;
    tradeName?: string | undefined;
    paymentGenId?: string | undefined;
    merchantPaymentId?: string | undefined;
    expiryDate?: moment.Moment;
    cardMask?: string | undefined;
    status?: string | undefined;
    cardType?: string | undefined;
    dateCreated?: moment.Moment | undefined;
    recurringType?: string | undefined;
}

export interface RecurringCardsListItemPagingResponse {
    totalCount?: number;
    data?: RecurringCardsListItem[] | undefined;
}

export enum RecurringPaymentType {
    None = 0,
    Client = 1,
    Merchant = 2,
}

export enum RecurringType {
    SMS = 0,
    DMS = 1,
}

export interface RefundModel {
    dateCreated?: moment.Moment | undefined;
    refundType?: string | undefined;
    status?: string | undefined;
    amount?: number;
    reversalTryCount?: number;
    userCreatorClientNo?: string | undefined;
    userCreatorFullName?: string | undefined;
    userCreatorPhoneNumber?: string | undefined;
}

export interface RegisterCompanyRequest {
    userId?: number | undefined;
    name?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    identificationNumber?: string | undefined;
    clientNo?: string | undefined;
    merchantType?: MerchantType;
    webPage?: RegisterWebPageRequest;
    qrPayment?: RegisterQRPaymentRequest;
    qrMerchant?: RegisterQRMerchantRequest;
    faceMerchant?: RegisterFaceMerchantRequest;
    posQRMerchant?: RegisterPosQRMerchantRequest;
}

export interface RegisterFaceMerchantRequest {
    address?: string | undefined;
    merchantExternalId?: string | undefined;
    mccCodeId?: number | undefined;
    businessField?: string | undefined;
    tradeName?: string | undefined;
    tradeNameEn?: string | undefined;
    description?: string | undefined;
    accountNumber?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    refundLimit?: MerchantRefundLimitDto;
    canRefund?: boolean;
}

export interface RegisterPosQRMerchantRequest {
    tradeName?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    mccCodeId?: number | undefined;
    terminal?: RegisterPosQRTerminalRequest;
}

export interface RegisterPosQRTerminal {
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    isBnplEnabled?: boolean;
}

export interface RegisterPosQRTerminalRequest {
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    isBnplEnabled?: boolean;
}

export interface RegisterQRMerchantRequest {
    mccCodeId?: number | undefined;
    businessField?: string | undefined;
    tradeName?: string | undefined;
    tradeNameEn?: string | undefined;
    description?: string | undefined;
    accountNumber?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    refundLimit?: MerchantRefundLimitDto;
    canRefund?: boolean;
}

export interface RegisterQRPaymentRequest {
    qrCode?: string | undefined;
    mccCodeId?: number | undefined;
    businessField?: string | undefined;
    tradeName?: string | undefined;
    tradeNameEn?: string | undefined;
    description?: string | undefined;
    accountNumber?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    refundLimit?: MerchantRefundLimitDto;
    canRefund?: boolean;
}

export enum RegisterUserType {
    ClientNo = 0,
    PersonalId = 1,
}

export interface RegisterWebPageRequest {
    address?: string | undefined;
    tradeName?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
    paymentLimit?: MerchantPaymentLimitDto;
    paymentMethods?: PayMethod[] | undefined;
    currencies?: Currency[] | undefined;
    refundLimit?: MerchantRefundLimitDto;
    mccCodeId?: number | undefined;
    masterWebPageId?: number | undefined;
    canRefund?: boolean;
    isRecurringEnabled?: boolean;
    isPayByLinkEnabled?: boolean;
    isBnplEnabled?: boolean;
    recurringType?: RecurringType;
}

export interface SearchQRCodesItem {
    code?: string | undefined;
    groupIdentifier?: string | undefined;
    adminUser?: string | undefined;
    createDate?: moment.Moment;
}

export interface SearchQRCodesItemPagingResponse {
    totalCount?: number;
    data?: SearchQRCodesItem[] | undefined;
}

export interface SearchTransactionsResponse {
    response?: TransactionDetailsModelPagingResponse;
    summaryAmount?: number;
}

export enum ServiceStatus {
    Pending = 0,
    Accepted = 1,
    Declined = 2,
    Blocked = 3,
}

export interface SubmitUserRegistration {
    firstname?: string | undefined;
    lastname?: string | undefined;
    clientNo?: string | undefined;
    personalId?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    registerUserType?: RegisterUserType;
}

export interface TransactionDetailsModel {
    id?: number | undefined;
    transactionId?: string | undefined;
    customerIp?: string | undefined;
    amount?: number | undefined;
    currency?: string | undefined;
    confirmedAmount?: number | undefined;
    description?: string | undefined;
    paymentMerchantId?: string | undefined;
    paymentMerchantName?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    userInfo?: string | undefined;
    rrn?: string | undefined;
    approvalCode?: string | undefined;
    responseCode?: string | undefined;
    createDate?: moment.Moment | undefined;
    finishDate?: moment.Moment | undefined;
    status?: PaymentStatus;
    readonly statusName?: string | undefined;
    paymentGenId?: string | undefined;
    parentPaymentGenId?: string | undefined;
    paymentChannel?: string | undefined;
    paymentMethod?: string | undefined;
    isBnpl?: boolean | undefined;
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    initiator?: string | undefined;
    transactionTypeName?: string | undefined;
    transactionType?: TransactionType;
    qrCode?: string | undefined;
    paymentCardNumber?: string | undefined;
    lastUpdateDate?: moment.Moment | undefined;
    responseBody?: string | undefined;
    returnUrl?: string | undefined;
    callbackUrl?: string | undefined;
    skipInfoMessage?: boolean;
    operatorContacts?: string | undefined;
    canBeReversed?: boolean;
    refunds?: RefundModel[] | undefined;
    returnAmount?: number;
    canCancelTransaction?: boolean;
    merchantPaymentId?: string | undefined;
    paymentTypeName?: string | undefined;
    paymentObjectTypeName?: string | undefined;
    readonly remainAmount?: number;
    expirationDate?: moment.Moment | undefined;
    initializerTypeName?: string | undefined;
    initializerType?: InitializerType;
    payByLinkId?: number | undefined;
}

export interface TransactionDetailsModelPagingResponse {
    totalCount?: number;
    data?: TransactionDetailsModel[] | undefined;
}

export interface TransactionPaymentLogResponse {
    response?: PaymentLogListItemPagingResponse;
}

export enum TransactionType {
    SMS = 2,
    DMS = 3,
    ZeroAuthorization = 4,
}

export interface UfcCertificateModel {
    merchantId?: string | undefined;
    validFrom?: moment.Moment;
    validTo?: moment.Moment;
    dateCreated?: moment.Moment;
    dateModified?: moment.Moment;
}

export interface UfcCertificateModelPagingResponse {
    totalCount?: number;
    data?: UfcCertificateModel[] | undefined;
}

export interface UpdateCompany {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    identificationNumber?: string | undefined;
    clientNo?: string | undefined;
}

export interface UpdateCurrency {
    currency?: Currency;
    action?: MultipleChoiceListActionType;
}

export interface UpdateFaceDevice {
    id?: number;
    status?: FaceDeviceStatus;
    comment?: string | undefined;
}

export interface UpdateFaceMerchant {
    id?: number;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    tradeName?: string | undefined;
    address?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
    refundLimitPerDay?: number | undefined;
    refundLimitPerMonth?: number | undefined;
    mccCodeId?: number | undefined;
    canRefund?: boolean;
}

export interface UpdateFaceTerminal {
    id?: number;
    status?: FaceTerminalStatus;
    comment?: string | undefined;
}

export interface UpdatePaymentMethod {
    paymentMethod?: PayMethod;
    action?: MultipleChoiceListActionType;
}

export interface UpdatePosQR {
    id?: number;
    tradeName?: string | undefined;
    mccCodeId?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    limitPerTransaction?: number | undefined;
    merchantExternalId?: string | undefined;
}

export interface UpdatePosQRTerminal {
    id?: number;
    terminalNo?: string | undefined;
    physicalTerminalNo?: string | undefined;
    isBnplEnabled?: boolean;
}

export interface UpdateQRMerchant {
    id?: number;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    refundLimitPerDay?: number | undefined;
    refundLimitPerMonth?: number | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
    accountNumber?: string | undefined;
    mccCodeId?: number | undefined;
    canRefund?: boolean;
}

export interface UpdateQRPayment {
    id?: number;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    refundLimitPerDay?: number | undefined;
    refundLimitPerMonth?: number | undefined;
    tradeNameEn?: string | undefined;
    tradeNameKa?: string | undefined;
    paymentMerchantExternalId?: string | undefined;
    accountNumber?: string | undefined;
    qrPaymentType?: QRPaymentType;
    mccCodeId?: number | undefined;
    canRefund?: boolean;
}

export interface UpdateUser {
    id?: number;
    clientNo?: string | undefined;
    personalId?: string | undefined;
}

export interface UpdateWebPage {
    id?: number;
    paymentMerchantExternalId?: string | undefined;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    limitStatus?: LimitStatus;
    testLimit?: number | undefined;
    refundLimitPerDay?: number | undefined;
    refundLimitPerMonth?: number | undefined;
    tradeName?: string | undefined;
    webAddress?: string | undefined;
    mccCodeId?: number | undefined;
    masterWebPageId?: number | undefined;
    canRefund?: boolean;
    isRecurringEnabled?: boolean;
    isSplitPaymentEnabled?: boolean;
    isPayByLinkEnabled?: boolean;
    isBnplEnabled?: boolean;
    recurringType?: RecurringType;
    updatePaymentMethods?: UpdatePaymentMethod[] | undefined;
    updateCurrencies?: UpdateCurrency[] | undefined;
}

export interface UserCompanyDetails {
    roleId?: number;
    paymentMerchants?: PaymentMerchantData[] | undefined;
    requestedMerchants?: PaymentMerchantData[] | undefined;
}

export interface UserDetailsModel {
    id?: number;
    firstname?: string | undefined;
    lastname?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
}

export interface UserProfileDetailsModel {
    id?: number;
    externalId?: string | undefined;
    username?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    clientNo?: string | undefined;
    personalId?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    status?: UserStatus;
    createdAt?: moment.Moment | undefined;
    notifyTransactions?: boolean;
    authorizationProvider?: AuthorizationProvider;
    readonly isBlockedExternally?: boolean;
}

export interface UserProfileModel {
    id?: number;
    username?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    clientNo?: string | undefined;
    personalId?: string | undefined;
    email?: string | undefined;
    status?: UserStatus;
    createdAt?: moment.Moment | undefined;
    authorizationProvider?: AuthorizationProvider;
}

export interface UserProfileModelPagingResponse {
    totalCount?: number;
    data?: UserProfileModel[] | undefined;
}

export interface UserReferenceModel {
    companyId?: number;
    companyName?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    merchantExternalId?: string | undefined;
}

export interface UserRegistrationResponseModel {
    user?: SubmitUserRegistration;
    message?: string | undefined;
}

export enum UserRole {
    SuperAdmin = 1,
    Admin = 2,
    Guest = 3,
    Developer = 4,
    None = -1,
}

export enum UserStatus {
    Active = 0,
    Blocked = 1,
    Deleted = 2,
}

export interface WebPageDetails {
    id?: number;
    mccCodeId?: number | undefined;
    status?: ServiceStatus;
    readonly statusName?: string | undefined;
    companyJuridicalName?: string | undefined;
    webAddress?: string | undefined;
    tradeName?: string | undefined;
    limitPerTransaction?: number | undefined;
    limitPerDay?: number | undefined;
    limitPerMonth?: number | undefined;
    limitStatus?: LimitStatus;
    testLimit?: number | undefined;
    refundLimit?: MerchantRefundLimit;
    paymentMerchantId?: number;
    paymentMerchantExternalId?: string | undefined;
    dateCreated?: moment.Moment;
    canRefund?: boolean;
    isRecurringEnabled?: boolean;
    isPayByLinkEnabled?: boolean;
    isBnplEnabled?: boolean;
    paymentMethods?: PaymentMethod[] | undefined;
    paymentCurrencies?: PaymentCurrency[] | undefined;
    callBacks?: CallBackDto[] | undefined;
    payByLinkProductListUrl?: string | undefined;
    clientAgreementUrl?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    childWebPages?: ChildWebPageDetails[] | undefined;
    masterWebPage?: MasterWebPageDetails;
    type?: WebPageMerchantType;
    readonly typeName?: string | undefined;
    companyId?: number;
    isSplitPaymentEnabled?: boolean;
    recurringType?: RecurringType;
}

export interface WebPageDropDownItem {
    readonly merchantExternalId?: string | undefined;
    readonly paymentMerchantId?: number;
    readonly webAddress?: string | undefined;
}

export interface WebPageListItem {
    id?: number;
    externalMerchantId?: string | undefined;
    tradeName?: string | undefined;
    address?: string | undefined;
    companyName?: string | undefined;
    companyIdentificationNumber?: string | undefined;
    status?: ServiceStatus;
    type?: WebPageMerchantType;
    readonly typeName?: string | undefined;
    readonly statusName?: string | undefined;
    isPayByLinkEnabled?: boolean;
    dateCreated?: moment.Moment;
}

export interface WebPageListItemPagingResponse {
    totalCount?: number;
    data?: WebPageListItem[] | undefined;
}

export enum WebPageMerchantType {
    Standart = 0,
    Master = 1,
    Child = 2,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}